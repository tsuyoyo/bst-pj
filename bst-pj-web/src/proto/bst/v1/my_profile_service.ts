// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v5.29.3
// source: bst/v1/my_profile_service.proto

/* eslint-disable */
import _m0 from "protobufjs/minimal";
import { UserProfile } from "./user";

export const protobufPackage = "bst.v1";

export interface GetMyProfileResponse {
  profile: UserProfile | undefined;
  email: string;
}

export interface UpdateIntroductionRequest {
  introduction: string;
}

export interface UpdateUserNameRequest {
  name: string;
}

export interface UpdateUserIconRequest {
  icon: string;
}

export interface UpdateUserGenresRequest {
  genreIds: number[];
}

export interface UpdateUserArtistsRequest {
  artistIds: number[];
}

export interface UpdateUserPartsRequest {
  partIds: number[];
}

export interface UpdateUserAreaRequest {
  prefectureIds: number[];
}

export interface UpdateResponse {
  success: boolean;
  profile: UserProfile | undefined;
}

function createBaseGetMyProfileResponse(): GetMyProfileResponse {
  return { profile: undefined, email: "" };
}

export const GetMyProfileResponse = {
  encode(message: GetMyProfileResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.profile !== undefined) {
      UserProfile.encode(message.profile, writer.uint32(10).fork()).ldelim();
    }
    if (message.email !== "") {
      writer.uint32(18).string(message.email);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetMyProfileResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMyProfileResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.profile = UserProfile.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.email = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetMyProfileResponse {
    return {
      profile: isSet(object.profile) ? UserProfile.fromJSON(object.profile) : undefined,
      email: isSet(object.email) ? globalThis.String(object.email) : "",
    };
  },

  toJSON(message: GetMyProfileResponse): unknown {
    const obj: any = {};
    if (message.profile !== undefined) {
      obj.profile = UserProfile.toJSON(message.profile);
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetMyProfileResponse>, I>>(base?: I): GetMyProfileResponse {
    return GetMyProfileResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetMyProfileResponse>, I>>(object: I): GetMyProfileResponse {
    const message = createBaseGetMyProfileResponse();
    message.profile = (object.profile !== undefined && object.profile !== null)
      ? UserProfile.fromPartial(object.profile)
      : undefined;
    message.email = object.email ?? "";
    return message;
  },
};

function createBaseUpdateIntroductionRequest(): UpdateIntroductionRequest {
  return { introduction: "" };
}

export const UpdateIntroductionRequest = {
  encode(message: UpdateIntroductionRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.introduction !== "") {
      writer.uint32(10).string(message.introduction);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateIntroductionRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateIntroductionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.introduction = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateIntroductionRequest {
    return { introduction: isSet(object.introduction) ? globalThis.String(object.introduction) : "" };
  },

  toJSON(message: UpdateIntroductionRequest): unknown {
    const obj: any = {};
    if (message.introduction !== "") {
      obj.introduction = message.introduction;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateIntroductionRequest>, I>>(base?: I): UpdateIntroductionRequest {
    return UpdateIntroductionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateIntroductionRequest>, I>>(object: I): UpdateIntroductionRequest {
    const message = createBaseUpdateIntroductionRequest();
    message.introduction = object.introduction ?? "";
    return message;
  },
};

function createBaseUpdateUserNameRequest(): UpdateUserNameRequest {
  return { name: "" };
}

export const UpdateUserNameRequest = {
  encode(message: UpdateUserNameRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateUserNameRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateUserNameRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateUserNameRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: UpdateUserNameRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateUserNameRequest>, I>>(base?: I): UpdateUserNameRequest {
    return UpdateUserNameRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateUserNameRequest>, I>>(object: I): UpdateUserNameRequest {
    const message = createBaseUpdateUserNameRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseUpdateUserIconRequest(): UpdateUserIconRequest {
  return { icon: "" };
}

export const UpdateUserIconRequest = {
  encode(message: UpdateUserIconRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.icon !== "") {
      writer.uint32(10).string(message.icon);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateUserIconRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateUserIconRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.icon = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateUserIconRequest {
    return { icon: isSet(object.icon) ? globalThis.String(object.icon) : "" };
  },

  toJSON(message: UpdateUserIconRequest): unknown {
    const obj: any = {};
    if (message.icon !== "") {
      obj.icon = message.icon;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateUserIconRequest>, I>>(base?: I): UpdateUserIconRequest {
    return UpdateUserIconRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateUserIconRequest>, I>>(object: I): UpdateUserIconRequest {
    const message = createBaseUpdateUserIconRequest();
    message.icon = object.icon ?? "";
    return message;
  },
};

function createBaseUpdateUserGenresRequest(): UpdateUserGenresRequest {
  return { genreIds: [] };
}

export const UpdateUserGenresRequest = {
  encode(message: UpdateUserGenresRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.genreIds) {
      writer.int32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateUserGenresRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateUserGenresRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.genreIds.push(reader.int32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.genreIds.push(reader.int32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateUserGenresRequest {
    return {
      genreIds: globalThis.Array.isArray(object?.genreIds) ? object.genreIds.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: UpdateUserGenresRequest): unknown {
    const obj: any = {};
    if (message.genreIds?.length) {
      obj.genreIds = message.genreIds.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateUserGenresRequest>, I>>(base?: I): UpdateUserGenresRequest {
    return UpdateUserGenresRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateUserGenresRequest>, I>>(object: I): UpdateUserGenresRequest {
    const message = createBaseUpdateUserGenresRequest();
    message.genreIds = object.genreIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseUpdateUserArtistsRequest(): UpdateUserArtistsRequest {
  return { artistIds: [] };
}

export const UpdateUserArtistsRequest = {
  encode(message: UpdateUserArtistsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.artistIds) {
      writer.int32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateUserArtistsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateUserArtistsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.artistIds.push(reader.int32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.artistIds.push(reader.int32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateUserArtistsRequest {
    return {
      artistIds: globalThis.Array.isArray(object?.artistIds)
        ? object.artistIds.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: UpdateUserArtistsRequest): unknown {
    const obj: any = {};
    if (message.artistIds?.length) {
      obj.artistIds = message.artistIds.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateUserArtistsRequest>, I>>(base?: I): UpdateUserArtistsRequest {
    return UpdateUserArtistsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateUserArtistsRequest>, I>>(object: I): UpdateUserArtistsRequest {
    const message = createBaseUpdateUserArtistsRequest();
    message.artistIds = object.artistIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseUpdateUserPartsRequest(): UpdateUserPartsRequest {
  return { partIds: [] };
}

export const UpdateUserPartsRequest = {
  encode(message: UpdateUserPartsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.partIds) {
      writer.int32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateUserPartsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateUserPartsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.partIds.push(reader.int32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.partIds.push(reader.int32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateUserPartsRequest {
    return {
      partIds: globalThis.Array.isArray(object?.partIds) ? object.partIds.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: UpdateUserPartsRequest): unknown {
    const obj: any = {};
    if (message.partIds?.length) {
      obj.partIds = message.partIds.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateUserPartsRequest>, I>>(base?: I): UpdateUserPartsRequest {
    return UpdateUserPartsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateUserPartsRequest>, I>>(object: I): UpdateUserPartsRequest {
    const message = createBaseUpdateUserPartsRequest();
    message.partIds = object.partIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseUpdateUserAreaRequest(): UpdateUserAreaRequest {
  return { prefectureIds: [] };
}

export const UpdateUserAreaRequest = {
  encode(message: UpdateUserAreaRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.prefectureIds) {
      writer.int32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateUserAreaRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateUserAreaRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.prefectureIds.push(reader.int32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.prefectureIds.push(reader.int32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateUserAreaRequest {
    return {
      prefectureIds: globalThis.Array.isArray(object?.prefectureIds)
        ? object.prefectureIds.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: UpdateUserAreaRequest): unknown {
    const obj: any = {};
    if (message.prefectureIds?.length) {
      obj.prefectureIds = message.prefectureIds.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateUserAreaRequest>, I>>(base?: I): UpdateUserAreaRequest {
    return UpdateUserAreaRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateUserAreaRequest>, I>>(object: I): UpdateUserAreaRequest {
    const message = createBaseUpdateUserAreaRequest();
    message.prefectureIds = object.prefectureIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseUpdateResponse(): UpdateResponse {
  return { success: false, profile: undefined };
}

export const UpdateResponse = {
  encode(message: UpdateResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.profile !== undefined) {
      UserProfile.encode(message.profile, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.profile = UserProfile.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      profile: isSet(object.profile) ? UserProfile.fromJSON(object.profile) : undefined,
    };
  },

  toJSON(message: UpdateResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.profile !== undefined) {
      obj.profile = UserProfile.toJSON(message.profile);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateResponse>, I>>(base?: I): UpdateResponse {
    return UpdateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateResponse>, I>>(object: I): UpdateResponse {
    const message = createBaseUpdateResponse();
    message.success = object.success ?? false;
    message.profile = (object.profile !== undefined && object.profile !== null)
      ? UserProfile.fromPartial(object.profile)
      : undefined;
    return message;
  },
};

export interface MyProfileService {
  UpdateIntroduction(request: UpdateIntroductionRequest): Promise<UpdateResponse>;
  UpdateUserName(request: UpdateUserNameRequest): Promise<UpdateResponse>;
  UpdateUserIcon(request: UpdateUserIconRequest): Promise<UpdateResponse>;
  UpdateUserGenres(request: UpdateUserGenresRequest): Promise<UpdateResponse>;
  UpdateUserArtists(request: UpdateUserArtistsRequest): Promise<UpdateResponse>;
  UpdateUserParts(request: UpdateUserPartsRequest): Promise<UpdateResponse>;
  UpdateUserArea(request: UpdateUserAreaRequest): Promise<UpdateResponse>;
}

export const MyProfileServiceServiceName = "bst.v1.MyProfileService";
export class MyProfileServiceClientImpl implements MyProfileService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || MyProfileServiceServiceName;
    this.rpc = rpc;
    this.UpdateIntroduction = this.UpdateIntroduction.bind(this);
    this.UpdateUserName = this.UpdateUserName.bind(this);
    this.UpdateUserIcon = this.UpdateUserIcon.bind(this);
    this.UpdateUserGenres = this.UpdateUserGenres.bind(this);
    this.UpdateUserArtists = this.UpdateUserArtists.bind(this);
    this.UpdateUserParts = this.UpdateUserParts.bind(this);
    this.UpdateUserArea = this.UpdateUserArea.bind(this);
  }
  UpdateIntroduction(request: UpdateIntroductionRequest): Promise<UpdateResponse> {
    const data = UpdateIntroductionRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateIntroduction", data);
    return promise.then((data) => UpdateResponse.decode(_m0.Reader.create(data)));
  }

  UpdateUserName(request: UpdateUserNameRequest): Promise<UpdateResponse> {
    const data = UpdateUserNameRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateUserName", data);
    return promise.then((data) => UpdateResponse.decode(_m0.Reader.create(data)));
  }

  UpdateUserIcon(request: UpdateUserIconRequest): Promise<UpdateResponse> {
    const data = UpdateUserIconRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateUserIcon", data);
    return promise.then((data) => UpdateResponse.decode(_m0.Reader.create(data)));
  }

  UpdateUserGenres(request: UpdateUserGenresRequest): Promise<UpdateResponse> {
    const data = UpdateUserGenresRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateUserGenres", data);
    return promise.then((data) => UpdateResponse.decode(_m0.Reader.create(data)));
  }

  UpdateUserArtists(request: UpdateUserArtistsRequest): Promise<UpdateResponse> {
    const data = UpdateUserArtistsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateUserArtists", data);
    return promise.then((data) => UpdateResponse.decode(_m0.Reader.create(data)));
  }

  UpdateUserParts(request: UpdateUserPartsRequest): Promise<UpdateResponse> {
    const data = UpdateUserPartsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateUserParts", data);
    return promise.then((data) => UpdateResponse.decode(_m0.Reader.create(data)));
  }

  UpdateUserArea(request: UpdateUserAreaRequest): Promise<UpdateResponse> {
    const data = UpdateUserAreaRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateUserArea", data);
    return promise.then((data) => UpdateResponse.decode(_m0.Reader.create(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
