// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v5.29.3
// source: bst/v1/session_titmetable_service.proto

/* eslint-disable */
import _m0 from "protobufjs/minimal";
import { Timetable, TimetableEntry } from "./session";

export const protobufPackage = "bst.v1";

export interface GetSessionTimetableRequest {
  sessionId: number;
}

export interface GetSessionTimetableResponse {
  timetable: Timetable | undefined;
}

export interface UpdateSessionTimetableRequest {
  sessionId: number;
  timetable: Timetable | undefined;
}

export interface UpdateSessionTimetableResponse {
  timetable: Timetable | undefined;
}

export interface GetOptimizedTimetableRequest {
  sessionId: number;
  optimizationRules: string[];
}

export interface GetOptimizedTimetableResponse {
  timetable: Timetable | undefined;
}

export interface GetTimetableProgressRequest {
  sessionId: number;
}

export interface GetTimetableProgressResponse {
  completedEntries: TimetableEntry[];
  currentEntry: TimetableEntry | undefined;
}

export interface UpdateTimetableProgressRequest {
  sessionId: number;
  currentEntryId: number;
}

export interface UpdateTimetableProgressResponse {
  success: boolean;
}

function createBaseGetSessionTimetableRequest(): GetSessionTimetableRequest {
  return { sessionId: 0 };
}

export const GetSessionTimetableRequest = {
  encode(message: GetSessionTimetableRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== 0) {
      writer.uint32(8).int32(message.sessionId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetSessionTimetableRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSessionTimetableRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sessionId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSessionTimetableRequest {
    return { sessionId: isSet(object.sessionId) ? globalThis.Number(object.sessionId) : 0 };
  },

  toJSON(message: GetSessionTimetableRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== 0) {
      obj.sessionId = Math.round(message.sessionId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSessionTimetableRequest>, I>>(base?: I): GetSessionTimetableRequest {
    return GetSessionTimetableRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSessionTimetableRequest>, I>>(object: I): GetSessionTimetableRequest {
    const message = createBaseGetSessionTimetableRequest();
    message.sessionId = object.sessionId ?? 0;
    return message;
  },
};

function createBaseGetSessionTimetableResponse(): GetSessionTimetableResponse {
  return { timetable: undefined };
}

export const GetSessionTimetableResponse = {
  encode(message: GetSessionTimetableResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.timetable !== undefined) {
      Timetable.encode(message.timetable, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetSessionTimetableResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSessionTimetableResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.timetable = Timetable.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSessionTimetableResponse {
    return { timetable: isSet(object.timetable) ? Timetable.fromJSON(object.timetable) : undefined };
  },

  toJSON(message: GetSessionTimetableResponse): unknown {
    const obj: any = {};
    if (message.timetable !== undefined) {
      obj.timetable = Timetable.toJSON(message.timetable);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSessionTimetableResponse>, I>>(base?: I): GetSessionTimetableResponse {
    return GetSessionTimetableResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSessionTimetableResponse>, I>>(object: I): GetSessionTimetableResponse {
    const message = createBaseGetSessionTimetableResponse();
    message.timetable = (object.timetable !== undefined && object.timetable !== null)
      ? Timetable.fromPartial(object.timetable)
      : undefined;
    return message;
  },
};

function createBaseUpdateSessionTimetableRequest(): UpdateSessionTimetableRequest {
  return { sessionId: 0, timetable: undefined };
}

export const UpdateSessionTimetableRequest = {
  encode(message: UpdateSessionTimetableRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== 0) {
      writer.uint32(8).int32(message.sessionId);
    }
    if (message.timetable !== undefined) {
      Timetable.encode(message.timetable, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateSessionTimetableRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSessionTimetableRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sessionId = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.timetable = Timetable.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateSessionTimetableRequest {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.Number(object.sessionId) : 0,
      timetable: isSet(object.timetable) ? Timetable.fromJSON(object.timetable) : undefined,
    };
  },

  toJSON(message: UpdateSessionTimetableRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== 0) {
      obj.sessionId = Math.round(message.sessionId);
    }
    if (message.timetable !== undefined) {
      obj.timetable = Timetable.toJSON(message.timetable);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateSessionTimetableRequest>, I>>(base?: I): UpdateSessionTimetableRequest {
    return UpdateSessionTimetableRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateSessionTimetableRequest>, I>>(
    object: I,
  ): UpdateSessionTimetableRequest {
    const message = createBaseUpdateSessionTimetableRequest();
    message.sessionId = object.sessionId ?? 0;
    message.timetable = (object.timetable !== undefined && object.timetable !== null)
      ? Timetable.fromPartial(object.timetable)
      : undefined;
    return message;
  },
};

function createBaseUpdateSessionTimetableResponse(): UpdateSessionTimetableResponse {
  return { timetable: undefined };
}

export const UpdateSessionTimetableResponse = {
  encode(message: UpdateSessionTimetableResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.timetable !== undefined) {
      Timetable.encode(message.timetable, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateSessionTimetableResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSessionTimetableResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.timetable = Timetable.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateSessionTimetableResponse {
    return { timetable: isSet(object.timetable) ? Timetable.fromJSON(object.timetable) : undefined };
  },

  toJSON(message: UpdateSessionTimetableResponse): unknown {
    const obj: any = {};
    if (message.timetable !== undefined) {
      obj.timetable = Timetable.toJSON(message.timetable);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateSessionTimetableResponse>, I>>(base?: I): UpdateSessionTimetableResponse {
    return UpdateSessionTimetableResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateSessionTimetableResponse>, I>>(
    object: I,
  ): UpdateSessionTimetableResponse {
    const message = createBaseUpdateSessionTimetableResponse();
    message.timetable = (object.timetable !== undefined && object.timetable !== null)
      ? Timetable.fromPartial(object.timetable)
      : undefined;
    return message;
  },
};

function createBaseGetOptimizedTimetableRequest(): GetOptimizedTimetableRequest {
  return { sessionId: 0, optimizationRules: [] };
}

export const GetOptimizedTimetableRequest = {
  encode(message: GetOptimizedTimetableRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== 0) {
      writer.uint32(8).int32(message.sessionId);
    }
    for (const v of message.optimizationRules) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetOptimizedTimetableRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOptimizedTimetableRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sessionId = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.optimizationRules.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetOptimizedTimetableRequest {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.Number(object.sessionId) : 0,
      optimizationRules: globalThis.Array.isArray(object?.optimizationRules)
        ? object.optimizationRules.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: GetOptimizedTimetableRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== 0) {
      obj.sessionId = Math.round(message.sessionId);
    }
    if (message.optimizationRules?.length) {
      obj.optimizationRules = message.optimizationRules;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetOptimizedTimetableRequest>, I>>(base?: I): GetOptimizedTimetableRequest {
    return GetOptimizedTimetableRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetOptimizedTimetableRequest>, I>>(object: I): GetOptimizedTimetableRequest {
    const message = createBaseGetOptimizedTimetableRequest();
    message.sessionId = object.sessionId ?? 0;
    message.optimizationRules = object.optimizationRules?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetOptimizedTimetableResponse(): GetOptimizedTimetableResponse {
  return { timetable: undefined };
}

export const GetOptimizedTimetableResponse = {
  encode(message: GetOptimizedTimetableResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.timetable !== undefined) {
      Timetable.encode(message.timetable, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetOptimizedTimetableResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOptimizedTimetableResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.timetable = Timetable.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetOptimizedTimetableResponse {
    return { timetable: isSet(object.timetable) ? Timetable.fromJSON(object.timetable) : undefined };
  },

  toJSON(message: GetOptimizedTimetableResponse): unknown {
    const obj: any = {};
    if (message.timetable !== undefined) {
      obj.timetable = Timetable.toJSON(message.timetable);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetOptimizedTimetableResponse>, I>>(base?: I): GetOptimizedTimetableResponse {
    return GetOptimizedTimetableResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetOptimizedTimetableResponse>, I>>(
    object: I,
  ): GetOptimizedTimetableResponse {
    const message = createBaseGetOptimizedTimetableResponse();
    message.timetable = (object.timetable !== undefined && object.timetable !== null)
      ? Timetable.fromPartial(object.timetable)
      : undefined;
    return message;
  },
};

function createBaseGetTimetableProgressRequest(): GetTimetableProgressRequest {
  return { sessionId: 0 };
}

export const GetTimetableProgressRequest = {
  encode(message: GetTimetableProgressRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== 0) {
      writer.uint32(8).int32(message.sessionId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetTimetableProgressRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTimetableProgressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sessionId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTimetableProgressRequest {
    return { sessionId: isSet(object.sessionId) ? globalThis.Number(object.sessionId) : 0 };
  },

  toJSON(message: GetTimetableProgressRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== 0) {
      obj.sessionId = Math.round(message.sessionId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTimetableProgressRequest>, I>>(base?: I): GetTimetableProgressRequest {
    return GetTimetableProgressRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTimetableProgressRequest>, I>>(object: I): GetTimetableProgressRequest {
    const message = createBaseGetTimetableProgressRequest();
    message.sessionId = object.sessionId ?? 0;
    return message;
  },
};

function createBaseGetTimetableProgressResponse(): GetTimetableProgressResponse {
  return { completedEntries: [], currentEntry: undefined };
}

export const GetTimetableProgressResponse = {
  encode(message: GetTimetableProgressResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.completedEntries) {
      TimetableEntry.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.currentEntry !== undefined) {
      TimetableEntry.encode(message.currentEntry, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetTimetableProgressResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTimetableProgressResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.completedEntries.push(TimetableEntry.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.currentEntry = TimetableEntry.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTimetableProgressResponse {
    return {
      completedEntries: globalThis.Array.isArray(object?.completedEntries)
        ? object.completedEntries.map((e: any) => TimetableEntry.fromJSON(e))
        : [],
      currentEntry: isSet(object.currentEntry) ? TimetableEntry.fromJSON(object.currentEntry) : undefined,
    };
  },

  toJSON(message: GetTimetableProgressResponse): unknown {
    const obj: any = {};
    if (message.completedEntries?.length) {
      obj.completedEntries = message.completedEntries.map((e) => TimetableEntry.toJSON(e));
    }
    if (message.currentEntry !== undefined) {
      obj.currentEntry = TimetableEntry.toJSON(message.currentEntry);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTimetableProgressResponse>, I>>(base?: I): GetTimetableProgressResponse {
    return GetTimetableProgressResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTimetableProgressResponse>, I>>(object: I): GetTimetableProgressResponse {
    const message = createBaseGetTimetableProgressResponse();
    message.completedEntries = object.completedEntries?.map((e) => TimetableEntry.fromPartial(e)) || [];
    message.currentEntry = (object.currentEntry !== undefined && object.currentEntry !== null)
      ? TimetableEntry.fromPartial(object.currentEntry)
      : undefined;
    return message;
  },
};

function createBaseUpdateTimetableProgressRequest(): UpdateTimetableProgressRequest {
  return { sessionId: 0, currentEntryId: 0 };
}

export const UpdateTimetableProgressRequest = {
  encode(message: UpdateTimetableProgressRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== 0) {
      writer.uint32(8).int32(message.sessionId);
    }
    if (message.currentEntryId !== 0) {
      writer.uint32(16).int32(message.currentEntryId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateTimetableProgressRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateTimetableProgressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sessionId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.currentEntryId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateTimetableProgressRequest {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.Number(object.sessionId) : 0,
      currentEntryId: isSet(object.currentEntryId) ? globalThis.Number(object.currentEntryId) : 0,
    };
  },

  toJSON(message: UpdateTimetableProgressRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== 0) {
      obj.sessionId = Math.round(message.sessionId);
    }
    if (message.currentEntryId !== 0) {
      obj.currentEntryId = Math.round(message.currentEntryId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateTimetableProgressRequest>, I>>(base?: I): UpdateTimetableProgressRequest {
    return UpdateTimetableProgressRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateTimetableProgressRequest>, I>>(
    object: I,
  ): UpdateTimetableProgressRequest {
    const message = createBaseUpdateTimetableProgressRequest();
    message.sessionId = object.sessionId ?? 0;
    message.currentEntryId = object.currentEntryId ?? 0;
    return message;
  },
};

function createBaseUpdateTimetableProgressResponse(): UpdateTimetableProgressResponse {
  return { success: false };
}

export const UpdateTimetableProgressResponse = {
  encode(message: UpdateTimetableProgressResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateTimetableProgressResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateTimetableProgressResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateTimetableProgressResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: UpdateTimetableProgressResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateTimetableProgressResponse>, I>>(base?: I): UpdateTimetableProgressResponse {
    return UpdateTimetableProgressResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateTimetableProgressResponse>, I>>(
    object: I,
  ): UpdateTimetableProgressResponse {
    const message = createBaseUpdateTimetableProgressResponse();
    message.success = object.success ?? false;
    return message;
  },
};

export interface SessionTimetableService {
  /** GET /sessions/{id}/timetable */
  GetSessionTimetable(request: GetSessionTimetableRequest): Promise<GetSessionTimetableResponse>;
  /** PUT /sessions/{id}/timetable */
  UpdateSessionTimetable(request: UpdateSessionTimetableRequest): Promise<UpdateSessionTimetableResponse>;
  /** GET /sessions/{id}/timetable/optimized */
  GetOptimizedTimetable(request: GetOptimizedTimetableRequest): Promise<GetOptimizedTimetableResponse>;
  /** GET /sessions/{id}/timetable/progress */
  GetTimetableProgress(request: GetTimetableProgressRequest): Promise<GetTimetableProgressResponse>;
  /** PUT /sessions/{id}/timetable/progress */
  UpdateTimetableProgress(request: UpdateTimetableProgressRequest): Promise<UpdateTimetableProgressResponse>;
}

export const SessionTimetableServiceServiceName = "bst.v1.SessionTimetableService";
export class SessionTimetableServiceClientImpl implements SessionTimetableService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || SessionTimetableServiceServiceName;
    this.rpc = rpc;
    this.GetSessionTimetable = this.GetSessionTimetable.bind(this);
    this.UpdateSessionTimetable = this.UpdateSessionTimetable.bind(this);
    this.GetOptimizedTimetable = this.GetOptimizedTimetable.bind(this);
    this.GetTimetableProgress = this.GetTimetableProgress.bind(this);
    this.UpdateTimetableProgress = this.UpdateTimetableProgress.bind(this);
  }
  GetSessionTimetable(request: GetSessionTimetableRequest): Promise<GetSessionTimetableResponse> {
    const data = GetSessionTimetableRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetSessionTimetable", data);
    return promise.then((data) => GetSessionTimetableResponse.decode(_m0.Reader.create(data)));
  }

  UpdateSessionTimetable(request: UpdateSessionTimetableRequest): Promise<UpdateSessionTimetableResponse> {
    const data = UpdateSessionTimetableRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateSessionTimetable", data);
    return promise.then((data) => UpdateSessionTimetableResponse.decode(_m0.Reader.create(data)));
  }

  GetOptimizedTimetable(request: GetOptimizedTimetableRequest): Promise<GetOptimizedTimetableResponse> {
    const data = GetOptimizedTimetableRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetOptimizedTimetable", data);
    return promise.then((data) => GetOptimizedTimetableResponse.decode(_m0.Reader.create(data)));
  }

  GetTimetableProgress(request: GetTimetableProgressRequest): Promise<GetTimetableProgressResponse> {
    const data = GetTimetableProgressRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetTimetableProgress", data);
    return promise.then((data) => GetTimetableProgressResponse.decode(_m0.Reader.create(data)));
  }

  UpdateTimetableProgress(request: UpdateTimetableProgressRequest): Promise<UpdateTimetableProgressResponse> {
    const data = UpdateTimetableProgressRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateTimetableProgress", data);
    return promise.then((data) => UpdateTimetableProgressResponse.decode(_m0.Reader.create(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
