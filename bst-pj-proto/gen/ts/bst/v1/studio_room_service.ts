// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v5.29.3
// source: bst/v1/studio_room_service.proto

/* eslint-disable */
import _m0 from "protobufjs/minimal";
import { StudioRoom, StudioRoomInfo } from "./location";

export const protobufPackage = "bst.v1";

export interface CreateStudioRoomRequest {
  studioId: number;
  name: string;
  capacity: number;
  price: number;
}

export interface CreateStudioRoomResponse {
  rooms: StudioRoom[];
}

export interface ListStudioRoomsRequest {
  studioId: number;
  pageSize: number;
  pageToken: number;
}

export interface ListStudioRoomsResponse {
  rooms: StudioRoom[];
  nextPageToken: string;
  totalSize: number;
}

export interface UpdateStudioRoomRequest {
  studioId: number;
  roomId: number;
  name: string;
  capacity: number;
  price: number;
}

export interface UpdateStudioRoomResponse {
  rooms: StudioRoom[];
}

export interface DeleteStudioRoomRequest {
  studioId: number;
  roomId: number;
}

export interface DeleteStudioRoomResponse {
  rooms: StudioRoom[];
}

export interface CreateStudioRoomInfoRequest {
  studioId: number;
  roomId: number;
  type: string;
  key: string;
  value: string;
}

export interface CreateStudioRoomInfoResponse {
  infos: StudioRoomInfo[];
}

export interface ListStudioRoomInfosRequest {
  studioId: number;
  roomId: number;
  pageSize: number;
  pageToken: number;
}

export interface ListStudioRoomInfosResponse {
  infos: StudioRoomInfo[];
  nextPageToken: string;
  totalSize: number;
}

export interface UpdateStudioRoomInfoRequest {
  studioId: number;
  roomId: number;
  infoId: number;
  type: string;
  key: string;
  value: string;
}

export interface UpdateStudioRoomInfoResponse {
  infos: StudioRoomInfo[];
}

export interface DeleteStudioRoomInfoRequest {
  studioId: number;
  roomId: number;
  infoId: number;
}

export interface DeleteStudioRoomInfoResponse {
  infos: StudioRoomInfo[];
}

function createBaseCreateStudioRoomRequest(): CreateStudioRoomRequest {
  return { studioId: 0, name: "", capacity: 0, price: 0 };
}

export const CreateStudioRoomRequest = {
  encode(message: CreateStudioRoomRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.studioId !== 0) {
      writer.uint32(8).int32(message.studioId);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.capacity !== 0) {
      writer.uint32(24).int32(message.capacity);
    }
    if (message.price !== 0) {
      writer.uint32(32).int32(message.price);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateStudioRoomRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateStudioRoomRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.studioId = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.capacity = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.price = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateStudioRoomRequest {
    return {
      studioId: isSet(object.studioId) ? globalThis.Number(object.studioId) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      capacity: isSet(object.capacity) ? globalThis.Number(object.capacity) : 0,
      price: isSet(object.price) ? globalThis.Number(object.price) : 0,
    };
  },

  toJSON(message: CreateStudioRoomRequest): unknown {
    const obj: any = {};
    if (message.studioId !== 0) {
      obj.studioId = Math.round(message.studioId);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.capacity !== 0) {
      obj.capacity = Math.round(message.capacity);
    }
    if (message.price !== 0) {
      obj.price = Math.round(message.price);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateStudioRoomRequest>, I>>(base?: I): CreateStudioRoomRequest {
    return CreateStudioRoomRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateStudioRoomRequest>, I>>(object: I): CreateStudioRoomRequest {
    const message = createBaseCreateStudioRoomRequest();
    message.studioId = object.studioId ?? 0;
    message.name = object.name ?? "";
    message.capacity = object.capacity ?? 0;
    message.price = object.price ?? 0;
    return message;
  },
};

function createBaseCreateStudioRoomResponse(): CreateStudioRoomResponse {
  return { rooms: [] };
}

export const CreateStudioRoomResponse = {
  encode(message: CreateStudioRoomResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.rooms) {
      StudioRoom.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateStudioRoomResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateStudioRoomResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.rooms.push(StudioRoom.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateStudioRoomResponse {
    return {
      rooms: globalThis.Array.isArray(object?.rooms) ? object.rooms.map((e: any) => StudioRoom.fromJSON(e)) : [],
    };
  },

  toJSON(message: CreateStudioRoomResponse): unknown {
    const obj: any = {};
    if (message.rooms?.length) {
      obj.rooms = message.rooms.map((e) => StudioRoom.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateStudioRoomResponse>, I>>(base?: I): CreateStudioRoomResponse {
    return CreateStudioRoomResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateStudioRoomResponse>, I>>(object: I): CreateStudioRoomResponse {
    const message = createBaseCreateStudioRoomResponse();
    message.rooms = object.rooms?.map((e) => StudioRoom.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListStudioRoomsRequest(): ListStudioRoomsRequest {
  return { studioId: 0, pageSize: 0, pageToken: 0 };
}

export const ListStudioRoomsRequest = {
  encode(message: ListStudioRoomsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.studioId !== 0) {
      writer.uint32(8).int32(message.studioId);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== 0) {
      writer.uint32(24).int32(message.pageToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListStudioRoomsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListStudioRoomsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.studioId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.pageToken = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListStudioRoomsRequest {
    return {
      studioId: isSet(object.studioId) ? globalThis.Number(object.studioId) : 0,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.Number(object.pageToken) : 0,
    };
  },

  toJSON(message: ListStudioRoomsRequest): unknown {
    const obj: any = {};
    if (message.studioId !== 0) {
      obj.studioId = Math.round(message.studioId);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== 0) {
      obj.pageToken = Math.round(message.pageToken);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListStudioRoomsRequest>, I>>(base?: I): ListStudioRoomsRequest {
    return ListStudioRoomsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListStudioRoomsRequest>, I>>(object: I): ListStudioRoomsRequest {
    const message = createBaseListStudioRoomsRequest();
    message.studioId = object.studioId ?? 0;
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? 0;
    return message;
  },
};

function createBaseListStudioRoomsResponse(): ListStudioRoomsResponse {
  return { rooms: [], nextPageToken: "", totalSize: 0 };
}

export const ListStudioRoomsResponse = {
  encode(message: ListStudioRoomsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.rooms) {
      StudioRoom.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    if (message.totalSize !== 0) {
      writer.uint32(24).int32(message.totalSize);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListStudioRoomsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListStudioRoomsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.rooms.push(StudioRoom.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.totalSize = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListStudioRoomsResponse {
    return {
      rooms: globalThis.Array.isArray(object?.rooms) ? object.rooms.map((e: any) => StudioRoom.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      totalSize: isSet(object.totalSize) ? globalThis.Number(object.totalSize) : 0,
    };
  },

  toJSON(message: ListStudioRoomsResponse): unknown {
    const obj: any = {};
    if (message.rooms?.length) {
      obj.rooms = message.rooms.map((e) => StudioRoom.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.totalSize !== 0) {
      obj.totalSize = Math.round(message.totalSize);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListStudioRoomsResponse>, I>>(base?: I): ListStudioRoomsResponse {
    return ListStudioRoomsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListStudioRoomsResponse>, I>>(object: I): ListStudioRoomsResponse {
    const message = createBaseListStudioRoomsResponse();
    message.rooms = object.rooms?.map((e) => StudioRoom.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.totalSize = object.totalSize ?? 0;
    return message;
  },
};

function createBaseUpdateStudioRoomRequest(): UpdateStudioRoomRequest {
  return { studioId: 0, roomId: 0, name: "", capacity: 0, price: 0 };
}

export const UpdateStudioRoomRequest = {
  encode(message: UpdateStudioRoomRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.studioId !== 0) {
      writer.uint32(8).int32(message.studioId);
    }
    if (message.roomId !== 0) {
      writer.uint32(16).int32(message.roomId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.capacity !== 0) {
      writer.uint32(32).int32(message.capacity);
    }
    if (message.price !== 0) {
      writer.uint32(40).int32(message.price);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateStudioRoomRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateStudioRoomRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.studioId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.roomId = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.capacity = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.price = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateStudioRoomRequest {
    return {
      studioId: isSet(object.studioId) ? globalThis.Number(object.studioId) : 0,
      roomId: isSet(object.roomId) ? globalThis.Number(object.roomId) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      capacity: isSet(object.capacity) ? globalThis.Number(object.capacity) : 0,
      price: isSet(object.price) ? globalThis.Number(object.price) : 0,
    };
  },

  toJSON(message: UpdateStudioRoomRequest): unknown {
    const obj: any = {};
    if (message.studioId !== 0) {
      obj.studioId = Math.round(message.studioId);
    }
    if (message.roomId !== 0) {
      obj.roomId = Math.round(message.roomId);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.capacity !== 0) {
      obj.capacity = Math.round(message.capacity);
    }
    if (message.price !== 0) {
      obj.price = Math.round(message.price);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateStudioRoomRequest>, I>>(base?: I): UpdateStudioRoomRequest {
    return UpdateStudioRoomRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateStudioRoomRequest>, I>>(object: I): UpdateStudioRoomRequest {
    const message = createBaseUpdateStudioRoomRequest();
    message.studioId = object.studioId ?? 0;
    message.roomId = object.roomId ?? 0;
    message.name = object.name ?? "";
    message.capacity = object.capacity ?? 0;
    message.price = object.price ?? 0;
    return message;
  },
};

function createBaseUpdateStudioRoomResponse(): UpdateStudioRoomResponse {
  return { rooms: [] };
}

export const UpdateStudioRoomResponse = {
  encode(message: UpdateStudioRoomResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.rooms) {
      StudioRoom.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateStudioRoomResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateStudioRoomResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.rooms.push(StudioRoom.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateStudioRoomResponse {
    return {
      rooms: globalThis.Array.isArray(object?.rooms) ? object.rooms.map((e: any) => StudioRoom.fromJSON(e)) : [],
    };
  },

  toJSON(message: UpdateStudioRoomResponse): unknown {
    const obj: any = {};
    if (message.rooms?.length) {
      obj.rooms = message.rooms.map((e) => StudioRoom.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateStudioRoomResponse>, I>>(base?: I): UpdateStudioRoomResponse {
    return UpdateStudioRoomResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateStudioRoomResponse>, I>>(object: I): UpdateStudioRoomResponse {
    const message = createBaseUpdateStudioRoomResponse();
    message.rooms = object.rooms?.map((e) => StudioRoom.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDeleteStudioRoomRequest(): DeleteStudioRoomRequest {
  return { studioId: 0, roomId: 0 };
}

export const DeleteStudioRoomRequest = {
  encode(message: DeleteStudioRoomRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.studioId !== 0) {
      writer.uint32(8).int32(message.studioId);
    }
    if (message.roomId !== 0) {
      writer.uint32(16).int32(message.roomId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteStudioRoomRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteStudioRoomRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.studioId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.roomId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteStudioRoomRequest {
    return {
      studioId: isSet(object.studioId) ? globalThis.Number(object.studioId) : 0,
      roomId: isSet(object.roomId) ? globalThis.Number(object.roomId) : 0,
    };
  },

  toJSON(message: DeleteStudioRoomRequest): unknown {
    const obj: any = {};
    if (message.studioId !== 0) {
      obj.studioId = Math.round(message.studioId);
    }
    if (message.roomId !== 0) {
      obj.roomId = Math.round(message.roomId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteStudioRoomRequest>, I>>(base?: I): DeleteStudioRoomRequest {
    return DeleteStudioRoomRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteStudioRoomRequest>, I>>(object: I): DeleteStudioRoomRequest {
    const message = createBaseDeleteStudioRoomRequest();
    message.studioId = object.studioId ?? 0;
    message.roomId = object.roomId ?? 0;
    return message;
  },
};

function createBaseDeleteStudioRoomResponse(): DeleteStudioRoomResponse {
  return { rooms: [] };
}

export const DeleteStudioRoomResponse = {
  encode(message: DeleteStudioRoomResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.rooms) {
      StudioRoom.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteStudioRoomResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteStudioRoomResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.rooms.push(StudioRoom.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteStudioRoomResponse {
    return {
      rooms: globalThis.Array.isArray(object?.rooms) ? object.rooms.map((e: any) => StudioRoom.fromJSON(e)) : [],
    };
  },

  toJSON(message: DeleteStudioRoomResponse): unknown {
    const obj: any = {};
    if (message.rooms?.length) {
      obj.rooms = message.rooms.map((e) => StudioRoom.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteStudioRoomResponse>, I>>(base?: I): DeleteStudioRoomResponse {
    return DeleteStudioRoomResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteStudioRoomResponse>, I>>(object: I): DeleteStudioRoomResponse {
    const message = createBaseDeleteStudioRoomResponse();
    message.rooms = object.rooms?.map((e) => StudioRoom.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCreateStudioRoomInfoRequest(): CreateStudioRoomInfoRequest {
  return { studioId: 0, roomId: 0, type: "", key: "", value: "" };
}

export const CreateStudioRoomInfoRequest = {
  encode(message: CreateStudioRoomInfoRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.studioId !== 0) {
      writer.uint32(8).int32(message.studioId);
    }
    if (message.roomId !== 0) {
      writer.uint32(16).int32(message.roomId);
    }
    if (message.type !== "") {
      writer.uint32(26).string(message.type);
    }
    if (message.key !== "") {
      writer.uint32(34).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(42).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateStudioRoomInfoRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateStudioRoomInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.studioId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.roomId = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.type = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.key = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateStudioRoomInfoRequest {
    return {
      studioId: isSet(object.studioId) ? globalThis.Number(object.studioId) : 0,
      roomId: isSet(object.roomId) ? globalThis.Number(object.roomId) : 0,
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CreateStudioRoomInfoRequest): unknown {
    const obj: any = {};
    if (message.studioId !== 0) {
      obj.studioId = Math.round(message.studioId);
    }
    if (message.roomId !== 0) {
      obj.roomId = Math.round(message.roomId);
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateStudioRoomInfoRequest>, I>>(base?: I): CreateStudioRoomInfoRequest {
    return CreateStudioRoomInfoRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateStudioRoomInfoRequest>, I>>(object: I): CreateStudioRoomInfoRequest {
    const message = createBaseCreateStudioRoomInfoRequest();
    message.studioId = object.studioId ?? 0;
    message.roomId = object.roomId ?? 0;
    message.type = object.type ?? "";
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCreateStudioRoomInfoResponse(): CreateStudioRoomInfoResponse {
  return { infos: [] };
}

export const CreateStudioRoomInfoResponse = {
  encode(message: CreateStudioRoomInfoResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.infos) {
      StudioRoomInfo.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateStudioRoomInfoResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateStudioRoomInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.infos.push(StudioRoomInfo.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateStudioRoomInfoResponse {
    return {
      infos: globalThis.Array.isArray(object?.infos) ? object.infos.map((e: any) => StudioRoomInfo.fromJSON(e)) : [],
    };
  },

  toJSON(message: CreateStudioRoomInfoResponse): unknown {
    const obj: any = {};
    if (message.infos?.length) {
      obj.infos = message.infos.map((e) => StudioRoomInfo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateStudioRoomInfoResponse>, I>>(base?: I): CreateStudioRoomInfoResponse {
    return CreateStudioRoomInfoResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateStudioRoomInfoResponse>, I>>(object: I): CreateStudioRoomInfoResponse {
    const message = createBaseCreateStudioRoomInfoResponse();
    message.infos = object.infos?.map((e) => StudioRoomInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListStudioRoomInfosRequest(): ListStudioRoomInfosRequest {
  return { studioId: 0, roomId: 0, pageSize: 0, pageToken: 0 };
}

export const ListStudioRoomInfosRequest = {
  encode(message: ListStudioRoomInfosRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.studioId !== 0) {
      writer.uint32(8).int32(message.studioId);
    }
    if (message.roomId !== 0) {
      writer.uint32(16).int32(message.roomId);
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    if (message.pageToken !== 0) {
      writer.uint32(32).int32(message.pageToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListStudioRoomInfosRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListStudioRoomInfosRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.studioId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.roomId = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.pageToken = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListStudioRoomInfosRequest {
    return {
      studioId: isSet(object.studioId) ? globalThis.Number(object.studioId) : 0,
      roomId: isSet(object.roomId) ? globalThis.Number(object.roomId) : 0,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.Number(object.pageToken) : 0,
    };
  },

  toJSON(message: ListStudioRoomInfosRequest): unknown {
    const obj: any = {};
    if (message.studioId !== 0) {
      obj.studioId = Math.round(message.studioId);
    }
    if (message.roomId !== 0) {
      obj.roomId = Math.round(message.roomId);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== 0) {
      obj.pageToken = Math.round(message.pageToken);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListStudioRoomInfosRequest>, I>>(base?: I): ListStudioRoomInfosRequest {
    return ListStudioRoomInfosRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListStudioRoomInfosRequest>, I>>(object: I): ListStudioRoomInfosRequest {
    const message = createBaseListStudioRoomInfosRequest();
    message.studioId = object.studioId ?? 0;
    message.roomId = object.roomId ?? 0;
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? 0;
    return message;
  },
};

function createBaseListStudioRoomInfosResponse(): ListStudioRoomInfosResponse {
  return { infos: [], nextPageToken: "", totalSize: 0 };
}

export const ListStudioRoomInfosResponse = {
  encode(message: ListStudioRoomInfosResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.infos) {
      StudioRoomInfo.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    if (message.totalSize !== 0) {
      writer.uint32(24).int32(message.totalSize);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListStudioRoomInfosResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListStudioRoomInfosResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.infos.push(StudioRoomInfo.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.totalSize = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListStudioRoomInfosResponse {
    return {
      infos: globalThis.Array.isArray(object?.infos) ? object.infos.map((e: any) => StudioRoomInfo.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      totalSize: isSet(object.totalSize) ? globalThis.Number(object.totalSize) : 0,
    };
  },

  toJSON(message: ListStudioRoomInfosResponse): unknown {
    const obj: any = {};
    if (message.infos?.length) {
      obj.infos = message.infos.map((e) => StudioRoomInfo.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.totalSize !== 0) {
      obj.totalSize = Math.round(message.totalSize);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListStudioRoomInfosResponse>, I>>(base?: I): ListStudioRoomInfosResponse {
    return ListStudioRoomInfosResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListStudioRoomInfosResponse>, I>>(object: I): ListStudioRoomInfosResponse {
    const message = createBaseListStudioRoomInfosResponse();
    message.infos = object.infos?.map((e) => StudioRoomInfo.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.totalSize = object.totalSize ?? 0;
    return message;
  },
};

function createBaseUpdateStudioRoomInfoRequest(): UpdateStudioRoomInfoRequest {
  return { studioId: 0, roomId: 0, infoId: 0, type: "", key: "", value: "" };
}

export const UpdateStudioRoomInfoRequest = {
  encode(message: UpdateStudioRoomInfoRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.studioId !== 0) {
      writer.uint32(8).int32(message.studioId);
    }
    if (message.roomId !== 0) {
      writer.uint32(16).int32(message.roomId);
    }
    if (message.infoId !== 0) {
      writer.uint32(24).int32(message.infoId);
    }
    if (message.type !== "") {
      writer.uint32(34).string(message.type);
    }
    if (message.key !== "") {
      writer.uint32(42).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(50).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateStudioRoomInfoRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateStudioRoomInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.studioId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.roomId = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.infoId = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.type = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.key = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateStudioRoomInfoRequest {
    return {
      studioId: isSet(object.studioId) ? globalThis.Number(object.studioId) : 0,
      roomId: isSet(object.roomId) ? globalThis.Number(object.roomId) : 0,
      infoId: isSet(object.infoId) ? globalThis.Number(object.infoId) : 0,
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: UpdateStudioRoomInfoRequest): unknown {
    const obj: any = {};
    if (message.studioId !== 0) {
      obj.studioId = Math.round(message.studioId);
    }
    if (message.roomId !== 0) {
      obj.roomId = Math.round(message.roomId);
    }
    if (message.infoId !== 0) {
      obj.infoId = Math.round(message.infoId);
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateStudioRoomInfoRequest>, I>>(base?: I): UpdateStudioRoomInfoRequest {
    return UpdateStudioRoomInfoRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateStudioRoomInfoRequest>, I>>(object: I): UpdateStudioRoomInfoRequest {
    const message = createBaseUpdateStudioRoomInfoRequest();
    message.studioId = object.studioId ?? 0;
    message.roomId = object.roomId ?? 0;
    message.infoId = object.infoId ?? 0;
    message.type = object.type ?? "";
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseUpdateStudioRoomInfoResponse(): UpdateStudioRoomInfoResponse {
  return { infos: [] };
}

export const UpdateStudioRoomInfoResponse = {
  encode(message: UpdateStudioRoomInfoResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.infos) {
      StudioRoomInfo.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateStudioRoomInfoResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateStudioRoomInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.infos.push(StudioRoomInfo.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateStudioRoomInfoResponse {
    return {
      infos: globalThis.Array.isArray(object?.infos) ? object.infos.map((e: any) => StudioRoomInfo.fromJSON(e)) : [],
    };
  },

  toJSON(message: UpdateStudioRoomInfoResponse): unknown {
    const obj: any = {};
    if (message.infos?.length) {
      obj.infos = message.infos.map((e) => StudioRoomInfo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateStudioRoomInfoResponse>, I>>(base?: I): UpdateStudioRoomInfoResponse {
    return UpdateStudioRoomInfoResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateStudioRoomInfoResponse>, I>>(object: I): UpdateStudioRoomInfoResponse {
    const message = createBaseUpdateStudioRoomInfoResponse();
    message.infos = object.infos?.map((e) => StudioRoomInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDeleteStudioRoomInfoRequest(): DeleteStudioRoomInfoRequest {
  return { studioId: 0, roomId: 0, infoId: 0 };
}

export const DeleteStudioRoomInfoRequest = {
  encode(message: DeleteStudioRoomInfoRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.studioId !== 0) {
      writer.uint32(8).int32(message.studioId);
    }
    if (message.roomId !== 0) {
      writer.uint32(16).int32(message.roomId);
    }
    if (message.infoId !== 0) {
      writer.uint32(24).int32(message.infoId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteStudioRoomInfoRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteStudioRoomInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.studioId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.roomId = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.infoId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteStudioRoomInfoRequest {
    return {
      studioId: isSet(object.studioId) ? globalThis.Number(object.studioId) : 0,
      roomId: isSet(object.roomId) ? globalThis.Number(object.roomId) : 0,
      infoId: isSet(object.infoId) ? globalThis.Number(object.infoId) : 0,
    };
  },

  toJSON(message: DeleteStudioRoomInfoRequest): unknown {
    const obj: any = {};
    if (message.studioId !== 0) {
      obj.studioId = Math.round(message.studioId);
    }
    if (message.roomId !== 0) {
      obj.roomId = Math.round(message.roomId);
    }
    if (message.infoId !== 0) {
      obj.infoId = Math.round(message.infoId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteStudioRoomInfoRequest>, I>>(base?: I): DeleteStudioRoomInfoRequest {
    return DeleteStudioRoomInfoRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteStudioRoomInfoRequest>, I>>(object: I): DeleteStudioRoomInfoRequest {
    const message = createBaseDeleteStudioRoomInfoRequest();
    message.studioId = object.studioId ?? 0;
    message.roomId = object.roomId ?? 0;
    message.infoId = object.infoId ?? 0;
    return message;
  },
};

function createBaseDeleteStudioRoomInfoResponse(): DeleteStudioRoomInfoResponse {
  return { infos: [] };
}

export const DeleteStudioRoomInfoResponse = {
  encode(message: DeleteStudioRoomInfoResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.infos) {
      StudioRoomInfo.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteStudioRoomInfoResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteStudioRoomInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.infos.push(StudioRoomInfo.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteStudioRoomInfoResponse {
    return {
      infos: globalThis.Array.isArray(object?.infos) ? object.infos.map((e: any) => StudioRoomInfo.fromJSON(e)) : [],
    };
  },

  toJSON(message: DeleteStudioRoomInfoResponse): unknown {
    const obj: any = {};
    if (message.infos?.length) {
      obj.infos = message.infos.map((e) => StudioRoomInfo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteStudioRoomInfoResponse>, I>>(base?: I): DeleteStudioRoomInfoResponse {
    return DeleteStudioRoomInfoResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteStudioRoomInfoResponse>, I>>(object: I): DeleteStudioRoomInfoResponse {
    const message = createBaseDeleteStudioRoomInfoResponse();
    message.infos = object.infos?.map((e) => StudioRoomInfo.fromPartial(e)) || [];
    return message;
  },
};

export interface StudioRoomService {
  /** POST /studios/{id}/rooms */
  CreateStudioRoom(request: CreateStudioRoomRequest): Promise<CreateStudioRoomResponse>;
  /** GET /studios/{id}/rooms */
  ListStudioRooms(request: ListStudioRoomsRequest): Promise<ListStudioRoomsResponse>;
  /** PUT /studios/{id}/rooms/{roomId} */
  UpdateStudioRoom(request: UpdateStudioRoomRequest): Promise<UpdateStudioRoomResponse>;
  /** DELETE /studios/{id}/rooms/{roomId} */
  DeleteStudioRoom(request: DeleteStudioRoomRequest): Promise<DeleteStudioRoomResponse>;
  /** POST /studios/{id}/rooms/{roomId}/infos */
  CreateStudioRoomInfo(request: CreateStudioRoomInfoRequest): Promise<CreateStudioRoomInfoResponse>;
  /** GET /studios/{id}/rooms/{roomId}/infos */
  ListStudioRoomInfos(request: ListStudioRoomInfosRequest): Promise<ListStudioRoomInfosResponse>;
  /** PUT /studios/{id}/rooms/{roomId}/infos/{infoId} */
  UpdateStudioRoomInfo(request: UpdateStudioRoomInfoRequest): Promise<UpdateStudioRoomInfoResponse>;
  /** DELETE /studios/{id}/rooms/{roomId}/infos/{infoId} */
  DeleteStudioRoomInfo(request: DeleteStudioRoomInfoRequest): Promise<DeleteStudioRoomInfoResponse>;
}

export const StudioRoomServiceServiceName = "bst.v1.StudioRoomService";
export class StudioRoomServiceClientImpl implements StudioRoomService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || StudioRoomServiceServiceName;
    this.rpc = rpc;
    this.CreateStudioRoom = this.CreateStudioRoom.bind(this);
    this.ListStudioRooms = this.ListStudioRooms.bind(this);
    this.UpdateStudioRoom = this.UpdateStudioRoom.bind(this);
    this.DeleteStudioRoom = this.DeleteStudioRoom.bind(this);
    this.CreateStudioRoomInfo = this.CreateStudioRoomInfo.bind(this);
    this.ListStudioRoomInfos = this.ListStudioRoomInfos.bind(this);
    this.UpdateStudioRoomInfo = this.UpdateStudioRoomInfo.bind(this);
    this.DeleteStudioRoomInfo = this.DeleteStudioRoomInfo.bind(this);
  }
  CreateStudioRoom(request: CreateStudioRoomRequest): Promise<CreateStudioRoomResponse> {
    const data = CreateStudioRoomRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateStudioRoom", data);
    return promise.then((data) => CreateStudioRoomResponse.decode(_m0.Reader.create(data)));
  }

  ListStudioRooms(request: ListStudioRoomsRequest): Promise<ListStudioRoomsResponse> {
    const data = ListStudioRoomsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListStudioRooms", data);
    return promise.then((data) => ListStudioRoomsResponse.decode(_m0.Reader.create(data)));
  }

  UpdateStudioRoom(request: UpdateStudioRoomRequest): Promise<UpdateStudioRoomResponse> {
    const data = UpdateStudioRoomRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateStudioRoom", data);
    return promise.then((data) => UpdateStudioRoomResponse.decode(_m0.Reader.create(data)));
  }

  DeleteStudioRoom(request: DeleteStudioRoomRequest): Promise<DeleteStudioRoomResponse> {
    const data = DeleteStudioRoomRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "DeleteStudioRoom", data);
    return promise.then((data) => DeleteStudioRoomResponse.decode(_m0.Reader.create(data)));
  }

  CreateStudioRoomInfo(request: CreateStudioRoomInfoRequest): Promise<CreateStudioRoomInfoResponse> {
    const data = CreateStudioRoomInfoRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateStudioRoomInfo", data);
    return promise.then((data) => CreateStudioRoomInfoResponse.decode(_m0.Reader.create(data)));
  }

  ListStudioRoomInfos(request: ListStudioRoomInfosRequest): Promise<ListStudioRoomInfosResponse> {
    const data = ListStudioRoomInfosRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListStudioRoomInfos", data);
    return promise.then((data) => ListStudioRoomInfosResponse.decode(_m0.Reader.create(data)));
  }

  UpdateStudioRoomInfo(request: UpdateStudioRoomInfoRequest): Promise<UpdateStudioRoomInfoResponse> {
    const data = UpdateStudioRoomInfoRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateStudioRoomInfo", data);
    return promise.then((data) => UpdateStudioRoomInfoResponse.decode(_m0.Reader.create(data)));
  }

  DeleteStudioRoomInfo(request: DeleteStudioRoomInfoRequest): Promise<DeleteStudioRoomInfoResponse> {
    const data = DeleteStudioRoomInfoRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "DeleteStudioRoomInfo", data);
    return promise.then((data) => DeleteStudioRoomInfoResponse.decode(_m0.Reader.create(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
