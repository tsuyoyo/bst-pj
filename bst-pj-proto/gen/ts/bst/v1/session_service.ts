// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v5.29.3
// source: bst/v1/session_service.proto

/* eslint-disable */
import _m0 from "protobufjs/minimal";
import { Timestamp } from "../../google/protobuf/timestamp";
import { Resource } from "./content";
import { Location, Studio } from "./location";
import {
  Session,
  SessionDetail,
  SessionStatus,
  sessionStatusFromJSON,
  sessionStatusToJSON,
  Timetable,
} from "./session";

export const protobufPackage = "bst.v1";

/** Session Management */
export interface CreateSessionRequest {
  title: string;
  description: string;
  eventDate: Date | undefined;
}

export interface CreateSessionResponse {
  session: Session | undefined;
}

export interface GetSessionRequest {
  sessionId: number;
}

export interface GetSessionResponse {
  session: Session | undefined;
  detail: SessionDetail | undefined;
}

export interface UpdateSessionRequest {
  title: string;
  description: string;
  eventDate: Date | undefined;
}

export interface UpdateSessionResponse {
  session: Session | undefined;
  detail: SessionDetail | undefined;
}

export interface UpdateSessionStudioRequest {
  sessionId: number;
  studio: Studio | undefined;
}

export interface UpdateSessionStudioResponse {
  session: Session | undefined;
  detail: SessionDetail | undefined;
}

export interface UpdateSessionStatusRequest {
  status: SessionStatus;
}

export interface UpdateSessionStatusResponse {
  session: Session | undefined;
  detail: SessionDetail | undefined;
}

export interface CancelSessionRequest {
  sessionId: number;
  reason: string;
}

export interface CancelSessionResponse {
  session: Session | undefined;
  detail: SessionDetail | undefined;
}

export interface DuplicateSessionRequest {
  sessionId: number;
  newEventDate: Date | undefined;
}

export interface DuplicateSessionResponse {
  session: SessionDetail | undefined;
}

/** Schedule & Location */
export interface UpdateSessionEntryStartDateRequest {
  sessionId: number;
  date: Date | undefined;
}

export interface UpdateSessionEntryStartDateResponse {
  session: SessionDetail | undefined;
}

export interface UpdateSessionEntryEndDateRequest {
  sessionId: number;
  date: Date | undefined;
}

export interface UpdateSessionEntryEndDateResponse {
  session: SessionDetail | undefined;
}

export interface UpdateSessionScheduleRequest {
  sessionId: number;
  timetable: Timetable | undefined;
}

export interface UpdateSessionScheduleResponse {
  timetable: Timetable | undefined;
}

export interface UpdateSessionLocationRequest {
  sessionId: number;
  location: Location | undefined;
}

export interface UpdateSessionLocationResponse {
  location: Location | undefined;
}

/** Song Resources */
export interface AddSessionSongResourceRequest {
  sessionId: number;
  songId: number;
  resource: Resource | undefined;
}

export interface AddSessionSongResourceResponse {
  resource: Resource | undefined;
}

export interface ListSessionSongResourcesRequest {
  sessionId: number;
  songId: number;
}

export interface ListSessionSongResourcesResponse {
  resources: Resource[];
  nextPageToken: string;
  totalSize: number;
}

export interface DeleteSessionSongResourceRequest {
  sessionId: number;
  songId: number;
  resourceId: number;
}

export interface DeleteSessionSongResourceResponse {
  success: boolean;
}

/** Communication */
export interface CreateSessionNotificationRequest {
  sessionId: number;
  content: string;
  userIds: number[];
}

export interface CreateSessionNotificationResponse {
  success: boolean;
}

/** Session Resources */
export interface AddSessionResourceRequest {
  sessionId: number;
  resource: Resource | undefined;
}

export interface AddSessionResourceResponse {
  resource: Resource | undefined;
}

export interface ListSessionResourcesRequest {
  sessionId: number;
}

export interface ListSessionResourcesResponse {
  resources: Resource[];
}

export interface DeleteSessionResourceRequest {
  sessionId: number;
  resourceId: number;
}

export interface DeleteSessionResourceResponse {
  success: boolean;
}

/** Related Sessions */
export interface ListRelatedSessionsRequest {
  sessionId: number;
}

export interface ListRelatedSessionsResponse {
  sessions: Session[];
}

export interface AddRelatedSessionRequest {
  sessionId: number;
  relatedSessionId: number;
}

export interface AddRelatedSessionResponse {
  success: boolean;
}

function createBaseCreateSessionRequest(): CreateSessionRequest {
  return { title: "", description: "", eventDate: undefined };
}

export const CreateSessionRequest = {
  encode(message: CreateSessionRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.eventDate !== undefined) {
      Timestamp.encode(toTimestamp(message.eventDate), writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateSessionRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.title = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.eventDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSessionRequest {
    return {
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      eventDate: isSet(object.eventDate) ? fromJsonTimestamp(object.eventDate) : undefined,
    };
  },

  toJSON(message: CreateSessionRequest): unknown {
    const obj: any = {};
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.eventDate !== undefined) {
      obj.eventDate = message.eventDate.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateSessionRequest>, I>>(base?: I): CreateSessionRequest {
    return CreateSessionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateSessionRequest>, I>>(object: I): CreateSessionRequest {
    const message = createBaseCreateSessionRequest();
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.eventDate = object.eventDate ?? undefined;
    return message;
  },
};

function createBaseCreateSessionResponse(): CreateSessionResponse {
  return { session: undefined };
}

export const CreateSessionResponse = {
  encode(message: CreateSessionResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.session !== undefined) {
      Session.encode(message.session, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateSessionResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.session = Session.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSessionResponse {
    return { session: isSet(object.session) ? Session.fromJSON(object.session) : undefined };
  },

  toJSON(message: CreateSessionResponse): unknown {
    const obj: any = {};
    if (message.session !== undefined) {
      obj.session = Session.toJSON(message.session);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateSessionResponse>, I>>(base?: I): CreateSessionResponse {
    return CreateSessionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateSessionResponse>, I>>(object: I): CreateSessionResponse {
    const message = createBaseCreateSessionResponse();
    message.session = (object.session !== undefined && object.session !== null)
      ? Session.fromPartial(object.session)
      : undefined;
    return message;
  },
};

function createBaseGetSessionRequest(): GetSessionRequest {
  return { sessionId: 0 };
}

export const GetSessionRequest = {
  encode(message: GetSessionRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== 0) {
      writer.uint32(8).int32(message.sessionId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetSessionRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sessionId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSessionRequest {
    return { sessionId: isSet(object.sessionId) ? globalThis.Number(object.sessionId) : 0 };
  },

  toJSON(message: GetSessionRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== 0) {
      obj.sessionId = Math.round(message.sessionId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSessionRequest>, I>>(base?: I): GetSessionRequest {
    return GetSessionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSessionRequest>, I>>(object: I): GetSessionRequest {
    const message = createBaseGetSessionRequest();
    message.sessionId = object.sessionId ?? 0;
    return message;
  },
};

function createBaseGetSessionResponse(): GetSessionResponse {
  return { session: undefined, detail: undefined };
}

export const GetSessionResponse = {
  encode(message: GetSessionResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.session !== undefined) {
      Session.encode(message.session, writer.uint32(10).fork()).ldelim();
    }
    if (message.detail !== undefined) {
      SessionDetail.encode(message.detail, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetSessionResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.session = Session.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.detail = SessionDetail.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSessionResponse {
    return {
      session: isSet(object.session) ? Session.fromJSON(object.session) : undefined,
      detail: isSet(object.detail) ? SessionDetail.fromJSON(object.detail) : undefined,
    };
  },

  toJSON(message: GetSessionResponse): unknown {
    const obj: any = {};
    if (message.session !== undefined) {
      obj.session = Session.toJSON(message.session);
    }
    if (message.detail !== undefined) {
      obj.detail = SessionDetail.toJSON(message.detail);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSessionResponse>, I>>(base?: I): GetSessionResponse {
    return GetSessionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSessionResponse>, I>>(object: I): GetSessionResponse {
    const message = createBaseGetSessionResponse();
    message.session = (object.session !== undefined && object.session !== null)
      ? Session.fromPartial(object.session)
      : undefined;
    message.detail = (object.detail !== undefined && object.detail !== null)
      ? SessionDetail.fromPartial(object.detail)
      : undefined;
    return message;
  },
};

function createBaseUpdateSessionRequest(): UpdateSessionRequest {
  return { title: "", description: "", eventDate: undefined };
}

export const UpdateSessionRequest = {
  encode(message: UpdateSessionRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.eventDate !== undefined) {
      Timestamp.encode(toTimestamp(message.eventDate), writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateSessionRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.title = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.eventDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateSessionRequest {
    return {
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      eventDate: isSet(object.eventDate) ? fromJsonTimestamp(object.eventDate) : undefined,
    };
  },

  toJSON(message: UpdateSessionRequest): unknown {
    const obj: any = {};
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.eventDate !== undefined) {
      obj.eventDate = message.eventDate.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateSessionRequest>, I>>(base?: I): UpdateSessionRequest {
    return UpdateSessionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateSessionRequest>, I>>(object: I): UpdateSessionRequest {
    const message = createBaseUpdateSessionRequest();
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.eventDate = object.eventDate ?? undefined;
    return message;
  },
};

function createBaseUpdateSessionResponse(): UpdateSessionResponse {
  return { session: undefined, detail: undefined };
}

export const UpdateSessionResponse = {
  encode(message: UpdateSessionResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.session !== undefined) {
      Session.encode(message.session, writer.uint32(10).fork()).ldelim();
    }
    if (message.detail !== undefined) {
      SessionDetail.encode(message.detail, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateSessionResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.session = Session.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.detail = SessionDetail.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateSessionResponse {
    return {
      session: isSet(object.session) ? Session.fromJSON(object.session) : undefined,
      detail: isSet(object.detail) ? SessionDetail.fromJSON(object.detail) : undefined,
    };
  },

  toJSON(message: UpdateSessionResponse): unknown {
    const obj: any = {};
    if (message.session !== undefined) {
      obj.session = Session.toJSON(message.session);
    }
    if (message.detail !== undefined) {
      obj.detail = SessionDetail.toJSON(message.detail);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateSessionResponse>, I>>(base?: I): UpdateSessionResponse {
    return UpdateSessionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateSessionResponse>, I>>(object: I): UpdateSessionResponse {
    const message = createBaseUpdateSessionResponse();
    message.session = (object.session !== undefined && object.session !== null)
      ? Session.fromPartial(object.session)
      : undefined;
    message.detail = (object.detail !== undefined && object.detail !== null)
      ? SessionDetail.fromPartial(object.detail)
      : undefined;
    return message;
  },
};

function createBaseUpdateSessionStudioRequest(): UpdateSessionStudioRequest {
  return { sessionId: 0, studio: undefined };
}

export const UpdateSessionStudioRequest = {
  encode(message: UpdateSessionStudioRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== 0) {
      writer.uint32(8).int32(message.sessionId);
    }
    if (message.studio !== undefined) {
      Studio.encode(message.studio, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateSessionStudioRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSessionStudioRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sessionId = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.studio = Studio.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateSessionStudioRequest {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.Number(object.sessionId) : 0,
      studio: isSet(object.studio) ? Studio.fromJSON(object.studio) : undefined,
    };
  },

  toJSON(message: UpdateSessionStudioRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== 0) {
      obj.sessionId = Math.round(message.sessionId);
    }
    if (message.studio !== undefined) {
      obj.studio = Studio.toJSON(message.studio);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateSessionStudioRequest>, I>>(base?: I): UpdateSessionStudioRequest {
    return UpdateSessionStudioRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateSessionStudioRequest>, I>>(object: I): UpdateSessionStudioRequest {
    const message = createBaseUpdateSessionStudioRequest();
    message.sessionId = object.sessionId ?? 0;
    message.studio = (object.studio !== undefined && object.studio !== null)
      ? Studio.fromPartial(object.studio)
      : undefined;
    return message;
  },
};

function createBaseUpdateSessionStudioResponse(): UpdateSessionStudioResponse {
  return { session: undefined, detail: undefined };
}

export const UpdateSessionStudioResponse = {
  encode(message: UpdateSessionStudioResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.session !== undefined) {
      Session.encode(message.session, writer.uint32(10).fork()).ldelim();
    }
    if (message.detail !== undefined) {
      SessionDetail.encode(message.detail, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateSessionStudioResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSessionStudioResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.session = Session.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.detail = SessionDetail.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateSessionStudioResponse {
    return {
      session: isSet(object.session) ? Session.fromJSON(object.session) : undefined,
      detail: isSet(object.detail) ? SessionDetail.fromJSON(object.detail) : undefined,
    };
  },

  toJSON(message: UpdateSessionStudioResponse): unknown {
    const obj: any = {};
    if (message.session !== undefined) {
      obj.session = Session.toJSON(message.session);
    }
    if (message.detail !== undefined) {
      obj.detail = SessionDetail.toJSON(message.detail);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateSessionStudioResponse>, I>>(base?: I): UpdateSessionStudioResponse {
    return UpdateSessionStudioResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateSessionStudioResponse>, I>>(object: I): UpdateSessionStudioResponse {
    const message = createBaseUpdateSessionStudioResponse();
    message.session = (object.session !== undefined && object.session !== null)
      ? Session.fromPartial(object.session)
      : undefined;
    message.detail = (object.detail !== undefined && object.detail !== null)
      ? SessionDetail.fromPartial(object.detail)
      : undefined;
    return message;
  },
};

function createBaseUpdateSessionStatusRequest(): UpdateSessionStatusRequest {
  return { status: 0 };
}

export const UpdateSessionStatusRequest = {
  encode(message: UpdateSessionStatusRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateSessionStatusRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSessionStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateSessionStatusRequest {
    return { status: isSet(object.status) ? sessionStatusFromJSON(object.status) : 0 };
  },

  toJSON(message: UpdateSessionStatusRequest): unknown {
    const obj: any = {};
    if (message.status !== 0) {
      obj.status = sessionStatusToJSON(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateSessionStatusRequest>, I>>(base?: I): UpdateSessionStatusRequest {
    return UpdateSessionStatusRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateSessionStatusRequest>, I>>(object: I): UpdateSessionStatusRequest {
    const message = createBaseUpdateSessionStatusRequest();
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseUpdateSessionStatusResponse(): UpdateSessionStatusResponse {
  return { session: undefined, detail: undefined };
}

export const UpdateSessionStatusResponse = {
  encode(message: UpdateSessionStatusResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.session !== undefined) {
      Session.encode(message.session, writer.uint32(10).fork()).ldelim();
    }
    if (message.detail !== undefined) {
      SessionDetail.encode(message.detail, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateSessionStatusResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSessionStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.session = Session.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.detail = SessionDetail.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateSessionStatusResponse {
    return {
      session: isSet(object.session) ? Session.fromJSON(object.session) : undefined,
      detail: isSet(object.detail) ? SessionDetail.fromJSON(object.detail) : undefined,
    };
  },

  toJSON(message: UpdateSessionStatusResponse): unknown {
    const obj: any = {};
    if (message.session !== undefined) {
      obj.session = Session.toJSON(message.session);
    }
    if (message.detail !== undefined) {
      obj.detail = SessionDetail.toJSON(message.detail);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateSessionStatusResponse>, I>>(base?: I): UpdateSessionStatusResponse {
    return UpdateSessionStatusResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateSessionStatusResponse>, I>>(object: I): UpdateSessionStatusResponse {
    const message = createBaseUpdateSessionStatusResponse();
    message.session = (object.session !== undefined && object.session !== null)
      ? Session.fromPartial(object.session)
      : undefined;
    message.detail = (object.detail !== undefined && object.detail !== null)
      ? SessionDetail.fromPartial(object.detail)
      : undefined;
    return message;
  },
};

function createBaseCancelSessionRequest(): CancelSessionRequest {
  return { sessionId: 0, reason: "" };
}

export const CancelSessionRequest = {
  encode(message: CancelSessionRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== 0) {
      writer.uint32(8).int32(message.sessionId);
    }
    if (message.reason !== "") {
      writer.uint32(18).string(message.reason);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CancelSessionRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sessionId = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.reason = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelSessionRequest {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.Number(object.sessionId) : 0,
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
    };
  },

  toJSON(message: CancelSessionRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== 0) {
      obj.sessionId = Math.round(message.sessionId);
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CancelSessionRequest>, I>>(base?: I): CancelSessionRequest {
    return CancelSessionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CancelSessionRequest>, I>>(object: I): CancelSessionRequest {
    const message = createBaseCancelSessionRequest();
    message.sessionId = object.sessionId ?? 0;
    message.reason = object.reason ?? "";
    return message;
  },
};

function createBaseCancelSessionResponse(): CancelSessionResponse {
  return { session: undefined, detail: undefined };
}

export const CancelSessionResponse = {
  encode(message: CancelSessionResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.session !== undefined) {
      Session.encode(message.session, writer.uint32(10).fork()).ldelim();
    }
    if (message.detail !== undefined) {
      SessionDetail.encode(message.detail, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CancelSessionResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.session = Session.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.detail = SessionDetail.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelSessionResponse {
    return {
      session: isSet(object.session) ? Session.fromJSON(object.session) : undefined,
      detail: isSet(object.detail) ? SessionDetail.fromJSON(object.detail) : undefined,
    };
  },

  toJSON(message: CancelSessionResponse): unknown {
    const obj: any = {};
    if (message.session !== undefined) {
      obj.session = Session.toJSON(message.session);
    }
    if (message.detail !== undefined) {
      obj.detail = SessionDetail.toJSON(message.detail);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CancelSessionResponse>, I>>(base?: I): CancelSessionResponse {
    return CancelSessionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CancelSessionResponse>, I>>(object: I): CancelSessionResponse {
    const message = createBaseCancelSessionResponse();
    message.session = (object.session !== undefined && object.session !== null)
      ? Session.fromPartial(object.session)
      : undefined;
    message.detail = (object.detail !== undefined && object.detail !== null)
      ? SessionDetail.fromPartial(object.detail)
      : undefined;
    return message;
  },
};

function createBaseDuplicateSessionRequest(): DuplicateSessionRequest {
  return { sessionId: 0, newEventDate: undefined };
}

export const DuplicateSessionRequest = {
  encode(message: DuplicateSessionRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== 0) {
      writer.uint32(8).int32(message.sessionId);
    }
    if (message.newEventDate !== undefined) {
      Timestamp.encode(toTimestamp(message.newEventDate), writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DuplicateSessionRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDuplicateSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sessionId = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.newEventDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DuplicateSessionRequest {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.Number(object.sessionId) : 0,
      newEventDate: isSet(object.newEventDate) ? fromJsonTimestamp(object.newEventDate) : undefined,
    };
  },

  toJSON(message: DuplicateSessionRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== 0) {
      obj.sessionId = Math.round(message.sessionId);
    }
    if (message.newEventDate !== undefined) {
      obj.newEventDate = message.newEventDate.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DuplicateSessionRequest>, I>>(base?: I): DuplicateSessionRequest {
    return DuplicateSessionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DuplicateSessionRequest>, I>>(object: I): DuplicateSessionRequest {
    const message = createBaseDuplicateSessionRequest();
    message.sessionId = object.sessionId ?? 0;
    message.newEventDate = object.newEventDate ?? undefined;
    return message;
  },
};

function createBaseDuplicateSessionResponse(): DuplicateSessionResponse {
  return { session: undefined };
}

export const DuplicateSessionResponse = {
  encode(message: DuplicateSessionResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.session !== undefined) {
      SessionDetail.encode(message.session, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DuplicateSessionResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDuplicateSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.session = SessionDetail.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DuplicateSessionResponse {
    return { session: isSet(object.session) ? SessionDetail.fromJSON(object.session) : undefined };
  },

  toJSON(message: DuplicateSessionResponse): unknown {
    const obj: any = {};
    if (message.session !== undefined) {
      obj.session = SessionDetail.toJSON(message.session);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DuplicateSessionResponse>, I>>(base?: I): DuplicateSessionResponse {
    return DuplicateSessionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DuplicateSessionResponse>, I>>(object: I): DuplicateSessionResponse {
    const message = createBaseDuplicateSessionResponse();
    message.session = (object.session !== undefined && object.session !== null)
      ? SessionDetail.fromPartial(object.session)
      : undefined;
    return message;
  },
};

function createBaseUpdateSessionEntryStartDateRequest(): UpdateSessionEntryStartDateRequest {
  return { sessionId: 0, date: undefined };
}

export const UpdateSessionEntryStartDateRequest = {
  encode(message: UpdateSessionEntryStartDateRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== 0) {
      writer.uint32(8).int32(message.sessionId);
    }
    if (message.date !== undefined) {
      Timestamp.encode(toTimestamp(message.date), writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateSessionEntryStartDateRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSessionEntryStartDateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sessionId = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.date = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateSessionEntryStartDateRequest {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.Number(object.sessionId) : 0,
      date: isSet(object.date) ? fromJsonTimestamp(object.date) : undefined,
    };
  },

  toJSON(message: UpdateSessionEntryStartDateRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== 0) {
      obj.sessionId = Math.round(message.sessionId);
    }
    if (message.date !== undefined) {
      obj.date = message.date.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateSessionEntryStartDateRequest>, I>>(
    base?: I,
  ): UpdateSessionEntryStartDateRequest {
    return UpdateSessionEntryStartDateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateSessionEntryStartDateRequest>, I>>(
    object: I,
  ): UpdateSessionEntryStartDateRequest {
    const message = createBaseUpdateSessionEntryStartDateRequest();
    message.sessionId = object.sessionId ?? 0;
    message.date = object.date ?? undefined;
    return message;
  },
};

function createBaseUpdateSessionEntryStartDateResponse(): UpdateSessionEntryStartDateResponse {
  return { session: undefined };
}

export const UpdateSessionEntryStartDateResponse = {
  encode(message: UpdateSessionEntryStartDateResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.session !== undefined) {
      SessionDetail.encode(message.session, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateSessionEntryStartDateResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSessionEntryStartDateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.session = SessionDetail.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateSessionEntryStartDateResponse {
    return { session: isSet(object.session) ? SessionDetail.fromJSON(object.session) : undefined };
  },

  toJSON(message: UpdateSessionEntryStartDateResponse): unknown {
    const obj: any = {};
    if (message.session !== undefined) {
      obj.session = SessionDetail.toJSON(message.session);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateSessionEntryStartDateResponse>, I>>(
    base?: I,
  ): UpdateSessionEntryStartDateResponse {
    return UpdateSessionEntryStartDateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateSessionEntryStartDateResponse>, I>>(
    object: I,
  ): UpdateSessionEntryStartDateResponse {
    const message = createBaseUpdateSessionEntryStartDateResponse();
    message.session = (object.session !== undefined && object.session !== null)
      ? SessionDetail.fromPartial(object.session)
      : undefined;
    return message;
  },
};

function createBaseUpdateSessionEntryEndDateRequest(): UpdateSessionEntryEndDateRequest {
  return { sessionId: 0, date: undefined };
}

export const UpdateSessionEntryEndDateRequest = {
  encode(message: UpdateSessionEntryEndDateRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== 0) {
      writer.uint32(8).int32(message.sessionId);
    }
    if (message.date !== undefined) {
      Timestamp.encode(toTimestamp(message.date), writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateSessionEntryEndDateRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSessionEntryEndDateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sessionId = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.date = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateSessionEntryEndDateRequest {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.Number(object.sessionId) : 0,
      date: isSet(object.date) ? fromJsonTimestamp(object.date) : undefined,
    };
  },

  toJSON(message: UpdateSessionEntryEndDateRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== 0) {
      obj.sessionId = Math.round(message.sessionId);
    }
    if (message.date !== undefined) {
      obj.date = message.date.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateSessionEntryEndDateRequest>, I>>(
    base?: I,
  ): UpdateSessionEntryEndDateRequest {
    return UpdateSessionEntryEndDateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateSessionEntryEndDateRequest>, I>>(
    object: I,
  ): UpdateSessionEntryEndDateRequest {
    const message = createBaseUpdateSessionEntryEndDateRequest();
    message.sessionId = object.sessionId ?? 0;
    message.date = object.date ?? undefined;
    return message;
  },
};

function createBaseUpdateSessionEntryEndDateResponse(): UpdateSessionEntryEndDateResponse {
  return { session: undefined };
}

export const UpdateSessionEntryEndDateResponse = {
  encode(message: UpdateSessionEntryEndDateResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.session !== undefined) {
      SessionDetail.encode(message.session, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateSessionEntryEndDateResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSessionEntryEndDateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.session = SessionDetail.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateSessionEntryEndDateResponse {
    return { session: isSet(object.session) ? SessionDetail.fromJSON(object.session) : undefined };
  },

  toJSON(message: UpdateSessionEntryEndDateResponse): unknown {
    const obj: any = {};
    if (message.session !== undefined) {
      obj.session = SessionDetail.toJSON(message.session);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateSessionEntryEndDateResponse>, I>>(
    base?: I,
  ): UpdateSessionEntryEndDateResponse {
    return UpdateSessionEntryEndDateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateSessionEntryEndDateResponse>, I>>(
    object: I,
  ): UpdateSessionEntryEndDateResponse {
    const message = createBaseUpdateSessionEntryEndDateResponse();
    message.session = (object.session !== undefined && object.session !== null)
      ? SessionDetail.fromPartial(object.session)
      : undefined;
    return message;
  },
};

function createBaseUpdateSessionScheduleRequest(): UpdateSessionScheduleRequest {
  return { sessionId: 0, timetable: undefined };
}

export const UpdateSessionScheduleRequest = {
  encode(message: UpdateSessionScheduleRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== 0) {
      writer.uint32(8).int32(message.sessionId);
    }
    if (message.timetable !== undefined) {
      Timetable.encode(message.timetable, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateSessionScheduleRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSessionScheduleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sessionId = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.timetable = Timetable.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateSessionScheduleRequest {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.Number(object.sessionId) : 0,
      timetable: isSet(object.timetable) ? Timetable.fromJSON(object.timetable) : undefined,
    };
  },

  toJSON(message: UpdateSessionScheduleRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== 0) {
      obj.sessionId = Math.round(message.sessionId);
    }
    if (message.timetable !== undefined) {
      obj.timetable = Timetable.toJSON(message.timetable);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateSessionScheduleRequest>, I>>(base?: I): UpdateSessionScheduleRequest {
    return UpdateSessionScheduleRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateSessionScheduleRequest>, I>>(object: I): UpdateSessionScheduleRequest {
    const message = createBaseUpdateSessionScheduleRequest();
    message.sessionId = object.sessionId ?? 0;
    message.timetable = (object.timetable !== undefined && object.timetable !== null)
      ? Timetable.fromPartial(object.timetable)
      : undefined;
    return message;
  },
};

function createBaseUpdateSessionScheduleResponse(): UpdateSessionScheduleResponse {
  return { timetable: undefined };
}

export const UpdateSessionScheduleResponse = {
  encode(message: UpdateSessionScheduleResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.timetable !== undefined) {
      Timetable.encode(message.timetable, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateSessionScheduleResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSessionScheduleResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.timetable = Timetable.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateSessionScheduleResponse {
    return { timetable: isSet(object.timetable) ? Timetable.fromJSON(object.timetable) : undefined };
  },

  toJSON(message: UpdateSessionScheduleResponse): unknown {
    const obj: any = {};
    if (message.timetable !== undefined) {
      obj.timetable = Timetable.toJSON(message.timetable);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateSessionScheduleResponse>, I>>(base?: I): UpdateSessionScheduleResponse {
    return UpdateSessionScheduleResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateSessionScheduleResponse>, I>>(
    object: I,
  ): UpdateSessionScheduleResponse {
    const message = createBaseUpdateSessionScheduleResponse();
    message.timetable = (object.timetable !== undefined && object.timetable !== null)
      ? Timetable.fromPartial(object.timetable)
      : undefined;
    return message;
  },
};

function createBaseUpdateSessionLocationRequest(): UpdateSessionLocationRequest {
  return { sessionId: 0, location: undefined };
}

export const UpdateSessionLocationRequest = {
  encode(message: UpdateSessionLocationRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== 0) {
      writer.uint32(8).int32(message.sessionId);
    }
    if (message.location !== undefined) {
      Location.encode(message.location, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateSessionLocationRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSessionLocationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sessionId = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.location = Location.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateSessionLocationRequest {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.Number(object.sessionId) : 0,
      location: isSet(object.location) ? Location.fromJSON(object.location) : undefined,
    };
  },

  toJSON(message: UpdateSessionLocationRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== 0) {
      obj.sessionId = Math.round(message.sessionId);
    }
    if (message.location !== undefined) {
      obj.location = Location.toJSON(message.location);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateSessionLocationRequest>, I>>(base?: I): UpdateSessionLocationRequest {
    return UpdateSessionLocationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateSessionLocationRequest>, I>>(object: I): UpdateSessionLocationRequest {
    const message = createBaseUpdateSessionLocationRequest();
    message.sessionId = object.sessionId ?? 0;
    message.location = (object.location !== undefined && object.location !== null)
      ? Location.fromPartial(object.location)
      : undefined;
    return message;
  },
};

function createBaseUpdateSessionLocationResponse(): UpdateSessionLocationResponse {
  return { location: undefined };
}

export const UpdateSessionLocationResponse = {
  encode(message: UpdateSessionLocationResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.location !== undefined) {
      Location.encode(message.location, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateSessionLocationResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSessionLocationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.location = Location.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateSessionLocationResponse {
    return { location: isSet(object.location) ? Location.fromJSON(object.location) : undefined };
  },

  toJSON(message: UpdateSessionLocationResponse): unknown {
    const obj: any = {};
    if (message.location !== undefined) {
      obj.location = Location.toJSON(message.location);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateSessionLocationResponse>, I>>(base?: I): UpdateSessionLocationResponse {
    return UpdateSessionLocationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateSessionLocationResponse>, I>>(
    object: I,
  ): UpdateSessionLocationResponse {
    const message = createBaseUpdateSessionLocationResponse();
    message.location = (object.location !== undefined && object.location !== null)
      ? Location.fromPartial(object.location)
      : undefined;
    return message;
  },
};

function createBaseAddSessionSongResourceRequest(): AddSessionSongResourceRequest {
  return { sessionId: 0, songId: 0, resource: undefined };
}

export const AddSessionSongResourceRequest = {
  encode(message: AddSessionSongResourceRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== 0) {
      writer.uint32(8).int32(message.sessionId);
    }
    if (message.songId !== 0) {
      writer.uint32(16).int32(message.songId);
    }
    if (message.resource !== undefined) {
      Resource.encode(message.resource, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AddSessionSongResourceRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddSessionSongResourceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sessionId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.songId = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.resource = Resource.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddSessionSongResourceRequest {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.Number(object.sessionId) : 0,
      songId: isSet(object.songId) ? globalThis.Number(object.songId) : 0,
      resource: isSet(object.resource) ? Resource.fromJSON(object.resource) : undefined,
    };
  },

  toJSON(message: AddSessionSongResourceRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== 0) {
      obj.sessionId = Math.round(message.sessionId);
    }
    if (message.songId !== 0) {
      obj.songId = Math.round(message.songId);
    }
    if (message.resource !== undefined) {
      obj.resource = Resource.toJSON(message.resource);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddSessionSongResourceRequest>, I>>(base?: I): AddSessionSongResourceRequest {
    return AddSessionSongResourceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddSessionSongResourceRequest>, I>>(
    object: I,
  ): AddSessionSongResourceRequest {
    const message = createBaseAddSessionSongResourceRequest();
    message.sessionId = object.sessionId ?? 0;
    message.songId = object.songId ?? 0;
    message.resource = (object.resource !== undefined && object.resource !== null)
      ? Resource.fromPartial(object.resource)
      : undefined;
    return message;
  },
};

function createBaseAddSessionSongResourceResponse(): AddSessionSongResourceResponse {
  return { resource: undefined };
}

export const AddSessionSongResourceResponse = {
  encode(message: AddSessionSongResourceResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.resource !== undefined) {
      Resource.encode(message.resource, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AddSessionSongResourceResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddSessionSongResourceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.resource = Resource.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddSessionSongResourceResponse {
    return { resource: isSet(object.resource) ? Resource.fromJSON(object.resource) : undefined };
  },

  toJSON(message: AddSessionSongResourceResponse): unknown {
    const obj: any = {};
    if (message.resource !== undefined) {
      obj.resource = Resource.toJSON(message.resource);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddSessionSongResourceResponse>, I>>(base?: I): AddSessionSongResourceResponse {
    return AddSessionSongResourceResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddSessionSongResourceResponse>, I>>(
    object: I,
  ): AddSessionSongResourceResponse {
    const message = createBaseAddSessionSongResourceResponse();
    message.resource = (object.resource !== undefined && object.resource !== null)
      ? Resource.fromPartial(object.resource)
      : undefined;
    return message;
  },
};

function createBaseListSessionSongResourcesRequest(): ListSessionSongResourcesRequest {
  return { sessionId: 0, songId: 0 };
}

export const ListSessionSongResourcesRequest = {
  encode(message: ListSessionSongResourcesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== 0) {
      writer.uint32(8).int32(message.sessionId);
    }
    if (message.songId !== 0) {
      writer.uint32(16).int32(message.songId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListSessionSongResourcesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSessionSongResourcesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sessionId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.songId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSessionSongResourcesRequest {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.Number(object.sessionId) : 0,
      songId: isSet(object.songId) ? globalThis.Number(object.songId) : 0,
    };
  },

  toJSON(message: ListSessionSongResourcesRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== 0) {
      obj.sessionId = Math.round(message.sessionId);
    }
    if (message.songId !== 0) {
      obj.songId = Math.round(message.songId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListSessionSongResourcesRequest>, I>>(base?: I): ListSessionSongResourcesRequest {
    return ListSessionSongResourcesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListSessionSongResourcesRequest>, I>>(
    object: I,
  ): ListSessionSongResourcesRequest {
    const message = createBaseListSessionSongResourcesRequest();
    message.sessionId = object.sessionId ?? 0;
    message.songId = object.songId ?? 0;
    return message;
  },
};

function createBaseListSessionSongResourcesResponse(): ListSessionSongResourcesResponse {
  return { resources: [], nextPageToken: "", totalSize: 0 };
}

export const ListSessionSongResourcesResponse = {
  encode(message: ListSessionSongResourcesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.resources) {
      Resource.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    if (message.totalSize !== 0) {
      writer.uint32(24).int32(message.totalSize);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListSessionSongResourcesResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSessionSongResourcesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.resources.push(Resource.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.totalSize = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSessionSongResourcesResponse {
    return {
      resources: globalThis.Array.isArray(object?.resources)
        ? object.resources.map((e: any) => Resource.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      totalSize: isSet(object.totalSize) ? globalThis.Number(object.totalSize) : 0,
    };
  },

  toJSON(message: ListSessionSongResourcesResponse): unknown {
    const obj: any = {};
    if (message.resources?.length) {
      obj.resources = message.resources.map((e) => Resource.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.totalSize !== 0) {
      obj.totalSize = Math.round(message.totalSize);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListSessionSongResourcesResponse>, I>>(
    base?: I,
  ): ListSessionSongResourcesResponse {
    return ListSessionSongResourcesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListSessionSongResourcesResponse>, I>>(
    object: I,
  ): ListSessionSongResourcesResponse {
    const message = createBaseListSessionSongResourcesResponse();
    message.resources = object.resources?.map((e) => Resource.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.totalSize = object.totalSize ?? 0;
    return message;
  },
};

function createBaseDeleteSessionSongResourceRequest(): DeleteSessionSongResourceRequest {
  return { sessionId: 0, songId: 0, resourceId: 0 };
}

export const DeleteSessionSongResourceRequest = {
  encode(message: DeleteSessionSongResourceRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== 0) {
      writer.uint32(8).int32(message.sessionId);
    }
    if (message.songId !== 0) {
      writer.uint32(16).int32(message.songId);
    }
    if (message.resourceId !== 0) {
      writer.uint32(24).int32(message.resourceId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteSessionSongResourceRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteSessionSongResourceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sessionId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.songId = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.resourceId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteSessionSongResourceRequest {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.Number(object.sessionId) : 0,
      songId: isSet(object.songId) ? globalThis.Number(object.songId) : 0,
      resourceId: isSet(object.resourceId) ? globalThis.Number(object.resourceId) : 0,
    };
  },

  toJSON(message: DeleteSessionSongResourceRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== 0) {
      obj.sessionId = Math.round(message.sessionId);
    }
    if (message.songId !== 0) {
      obj.songId = Math.round(message.songId);
    }
    if (message.resourceId !== 0) {
      obj.resourceId = Math.round(message.resourceId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteSessionSongResourceRequest>, I>>(
    base?: I,
  ): DeleteSessionSongResourceRequest {
    return DeleteSessionSongResourceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteSessionSongResourceRequest>, I>>(
    object: I,
  ): DeleteSessionSongResourceRequest {
    const message = createBaseDeleteSessionSongResourceRequest();
    message.sessionId = object.sessionId ?? 0;
    message.songId = object.songId ?? 0;
    message.resourceId = object.resourceId ?? 0;
    return message;
  },
};

function createBaseDeleteSessionSongResourceResponse(): DeleteSessionSongResourceResponse {
  return { success: false };
}

export const DeleteSessionSongResourceResponse = {
  encode(message: DeleteSessionSongResourceResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteSessionSongResourceResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteSessionSongResourceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteSessionSongResourceResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: DeleteSessionSongResourceResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteSessionSongResourceResponse>, I>>(
    base?: I,
  ): DeleteSessionSongResourceResponse {
    return DeleteSessionSongResourceResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteSessionSongResourceResponse>, I>>(
    object: I,
  ): DeleteSessionSongResourceResponse {
    const message = createBaseDeleteSessionSongResourceResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseCreateSessionNotificationRequest(): CreateSessionNotificationRequest {
  return { sessionId: 0, content: "", userIds: [] };
}

export const CreateSessionNotificationRequest = {
  encode(message: CreateSessionNotificationRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== 0) {
      writer.uint32(8).int32(message.sessionId);
    }
    if (message.content !== "") {
      writer.uint32(18).string(message.content);
    }
    writer.uint32(26).fork();
    for (const v of message.userIds) {
      writer.int32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateSessionNotificationRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSessionNotificationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sessionId = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.content = reader.string();
          continue;
        case 3:
          if (tag === 24) {
            message.userIds.push(reader.int32());

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.userIds.push(reader.int32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSessionNotificationRequest {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.Number(object.sessionId) : 0,
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      userIds: globalThis.Array.isArray(object?.userIds) ? object.userIds.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: CreateSessionNotificationRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== 0) {
      obj.sessionId = Math.round(message.sessionId);
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.userIds?.length) {
      obj.userIds = message.userIds.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateSessionNotificationRequest>, I>>(
    base?: I,
  ): CreateSessionNotificationRequest {
    return CreateSessionNotificationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateSessionNotificationRequest>, I>>(
    object: I,
  ): CreateSessionNotificationRequest {
    const message = createBaseCreateSessionNotificationRequest();
    message.sessionId = object.sessionId ?? 0;
    message.content = object.content ?? "";
    message.userIds = object.userIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseCreateSessionNotificationResponse(): CreateSessionNotificationResponse {
  return { success: false };
}

export const CreateSessionNotificationResponse = {
  encode(message: CreateSessionNotificationResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateSessionNotificationResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSessionNotificationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSessionNotificationResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: CreateSessionNotificationResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateSessionNotificationResponse>, I>>(
    base?: I,
  ): CreateSessionNotificationResponse {
    return CreateSessionNotificationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateSessionNotificationResponse>, I>>(
    object: I,
  ): CreateSessionNotificationResponse {
    const message = createBaseCreateSessionNotificationResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseAddSessionResourceRequest(): AddSessionResourceRequest {
  return { sessionId: 0, resource: undefined };
}

export const AddSessionResourceRequest = {
  encode(message: AddSessionResourceRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== 0) {
      writer.uint32(8).int32(message.sessionId);
    }
    if (message.resource !== undefined) {
      Resource.encode(message.resource, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AddSessionResourceRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddSessionResourceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sessionId = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.resource = Resource.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddSessionResourceRequest {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.Number(object.sessionId) : 0,
      resource: isSet(object.resource) ? Resource.fromJSON(object.resource) : undefined,
    };
  },

  toJSON(message: AddSessionResourceRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== 0) {
      obj.sessionId = Math.round(message.sessionId);
    }
    if (message.resource !== undefined) {
      obj.resource = Resource.toJSON(message.resource);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddSessionResourceRequest>, I>>(base?: I): AddSessionResourceRequest {
    return AddSessionResourceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddSessionResourceRequest>, I>>(object: I): AddSessionResourceRequest {
    const message = createBaseAddSessionResourceRequest();
    message.sessionId = object.sessionId ?? 0;
    message.resource = (object.resource !== undefined && object.resource !== null)
      ? Resource.fromPartial(object.resource)
      : undefined;
    return message;
  },
};

function createBaseAddSessionResourceResponse(): AddSessionResourceResponse {
  return { resource: undefined };
}

export const AddSessionResourceResponse = {
  encode(message: AddSessionResourceResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.resource !== undefined) {
      Resource.encode(message.resource, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AddSessionResourceResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddSessionResourceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.resource = Resource.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddSessionResourceResponse {
    return { resource: isSet(object.resource) ? Resource.fromJSON(object.resource) : undefined };
  },

  toJSON(message: AddSessionResourceResponse): unknown {
    const obj: any = {};
    if (message.resource !== undefined) {
      obj.resource = Resource.toJSON(message.resource);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddSessionResourceResponse>, I>>(base?: I): AddSessionResourceResponse {
    return AddSessionResourceResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddSessionResourceResponse>, I>>(object: I): AddSessionResourceResponse {
    const message = createBaseAddSessionResourceResponse();
    message.resource = (object.resource !== undefined && object.resource !== null)
      ? Resource.fromPartial(object.resource)
      : undefined;
    return message;
  },
};

function createBaseListSessionResourcesRequest(): ListSessionResourcesRequest {
  return { sessionId: 0 };
}

export const ListSessionResourcesRequest = {
  encode(message: ListSessionResourcesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== 0) {
      writer.uint32(8).int32(message.sessionId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListSessionResourcesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSessionResourcesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sessionId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSessionResourcesRequest {
    return { sessionId: isSet(object.sessionId) ? globalThis.Number(object.sessionId) : 0 };
  },

  toJSON(message: ListSessionResourcesRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== 0) {
      obj.sessionId = Math.round(message.sessionId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListSessionResourcesRequest>, I>>(base?: I): ListSessionResourcesRequest {
    return ListSessionResourcesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListSessionResourcesRequest>, I>>(object: I): ListSessionResourcesRequest {
    const message = createBaseListSessionResourcesRequest();
    message.sessionId = object.sessionId ?? 0;
    return message;
  },
};

function createBaseListSessionResourcesResponse(): ListSessionResourcesResponse {
  return { resources: [] };
}

export const ListSessionResourcesResponse = {
  encode(message: ListSessionResourcesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.resources) {
      Resource.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListSessionResourcesResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSessionResourcesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.resources.push(Resource.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSessionResourcesResponse {
    return {
      resources: globalThis.Array.isArray(object?.resources)
        ? object.resources.map((e: any) => Resource.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListSessionResourcesResponse): unknown {
    const obj: any = {};
    if (message.resources?.length) {
      obj.resources = message.resources.map((e) => Resource.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListSessionResourcesResponse>, I>>(base?: I): ListSessionResourcesResponse {
    return ListSessionResourcesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListSessionResourcesResponse>, I>>(object: I): ListSessionResourcesResponse {
    const message = createBaseListSessionResourcesResponse();
    message.resources = object.resources?.map((e) => Resource.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDeleteSessionResourceRequest(): DeleteSessionResourceRequest {
  return { sessionId: 0, resourceId: 0 };
}

export const DeleteSessionResourceRequest = {
  encode(message: DeleteSessionResourceRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== 0) {
      writer.uint32(8).int32(message.sessionId);
    }
    if (message.resourceId !== 0) {
      writer.uint32(16).int32(message.resourceId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteSessionResourceRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteSessionResourceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sessionId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.resourceId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteSessionResourceRequest {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.Number(object.sessionId) : 0,
      resourceId: isSet(object.resourceId) ? globalThis.Number(object.resourceId) : 0,
    };
  },

  toJSON(message: DeleteSessionResourceRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== 0) {
      obj.sessionId = Math.round(message.sessionId);
    }
    if (message.resourceId !== 0) {
      obj.resourceId = Math.round(message.resourceId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteSessionResourceRequest>, I>>(base?: I): DeleteSessionResourceRequest {
    return DeleteSessionResourceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteSessionResourceRequest>, I>>(object: I): DeleteSessionResourceRequest {
    const message = createBaseDeleteSessionResourceRequest();
    message.sessionId = object.sessionId ?? 0;
    message.resourceId = object.resourceId ?? 0;
    return message;
  },
};

function createBaseDeleteSessionResourceResponse(): DeleteSessionResourceResponse {
  return { success: false };
}

export const DeleteSessionResourceResponse = {
  encode(message: DeleteSessionResourceResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteSessionResourceResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteSessionResourceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteSessionResourceResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: DeleteSessionResourceResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteSessionResourceResponse>, I>>(base?: I): DeleteSessionResourceResponse {
    return DeleteSessionResourceResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteSessionResourceResponse>, I>>(
    object: I,
  ): DeleteSessionResourceResponse {
    const message = createBaseDeleteSessionResourceResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseListRelatedSessionsRequest(): ListRelatedSessionsRequest {
  return { sessionId: 0 };
}

export const ListRelatedSessionsRequest = {
  encode(message: ListRelatedSessionsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== 0) {
      writer.uint32(8).int32(message.sessionId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListRelatedSessionsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRelatedSessionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sessionId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRelatedSessionsRequest {
    return { sessionId: isSet(object.sessionId) ? globalThis.Number(object.sessionId) : 0 };
  },

  toJSON(message: ListRelatedSessionsRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== 0) {
      obj.sessionId = Math.round(message.sessionId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListRelatedSessionsRequest>, I>>(base?: I): ListRelatedSessionsRequest {
    return ListRelatedSessionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListRelatedSessionsRequest>, I>>(object: I): ListRelatedSessionsRequest {
    const message = createBaseListRelatedSessionsRequest();
    message.sessionId = object.sessionId ?? 0;
    return message;
  },
};

function createBaseListRelatedSessionsResponse(): ListRelatedSessionsResponse {
  return { sessions: [] };
}

export const ListRelatedSessionsResponse = {
  encode(message: ListRelatedSessionsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.sessions) {
      Session.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListRelatedSessionsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRelatedSessionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sessions.push(Session.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRelatedSessionsResponse {
    return {
      sessions: globalThis.Array.isArray(object?.sessions) ? object.sessions.map((e: any) => Session.fromJSON(e)) : [],
    };
  },

  toJSON(message: ListRelatedSessionsResponse): unknown {
    const obj: any = {};
    if (message.sessions?.length) {
      obj.sessions = message.sessions.map((e) => Session.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListRelatedSessionsResponse>, I>>(base?: I): ListRelatedSessionsResponse {
    return ListRelatedSessionsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListRelatedSessionsResponse>, I>>(object: I): ListRelatedSessionsResponse {
    const message = createBaseListRelatedSessionsResponse();
    message.sessions = object.sessions?.map((e) => Session.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAddRelatedSessionRequest(): AddRelatedSessionRequest {
  return { sessionId: 0, relatedSessionId: 0 };
}

export const AddRelatedSessionRequest = {
  encode(message: AddRelatedSessionRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== 0) {
      writer.uint32(8).int32(message.sessionId);
    }
    if (message.relatedSessionId !== 0) {
      writer.uint32(16).int32(message.relatedSessionId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AddRelatedSessionRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddRelatedSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sessionId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.relatedSessionId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddRelatedSessionRequest {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.Number(object.sessionId) : 0,
      relatedSessionId: isSet(object.relatedSessionId) ? globalThis.Number(object.relatedSessionId) : 0,
    };
  },

  toJSON(message: AddRelatedSessionRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== 0) {
      obj.sessionId = Math.round(message.sessionId);
    }
    if (message.relatedSessionId !== 0) {
      obj.relatedSessionId = Math.round(message.relatedSessionId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddRelatedSessionRequest>, I>>(base?: I): AddRelatedSessionRequest {
    return AddRelatedSessionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddRelatedSessionRequest>, I>>(object: I): AddRelatedSessionRequest {
    const message = createBaseAddRelatedSessionRequest();
    message.sessionId = object.sessionId ?? 0;
    message.relatedSessionId = object.relatedSessionId ?? 0;
    return message;
  },
};

function createBaseAddRelatedSessionResponse(): AddRelatedSessionResponse {
  return { success: false };
}

export const AddRelatedSessionResponse = {
  encode(message: AddRelatedSessionResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AddRelatedSessionResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddRelatedSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddRelatedSessionResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: AddRelatedSessionResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddRelatedSessionResponse>, I>>(base?: I): AddRelatedSessionResponse {
    return AddRelatedSessionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddRelatedSessionResponse>, I>>(object: I): AddRelatedSessionResponse {
    const message = createBaseAddRelatedSessionResponse();
    message.success = object.success ?? false;
    return message;
  },
};

export interface SessionService {
  /**
   * Session Management
   * POST /sessions
   */
  CreateSession(request: CreateSessionRequest): Promise<CreateSessionResponse>;
  /** GET /sessions/{id} */
  GetSession(request: GetSessionRequest): Promise<GetSessionResponse>;
  /** PUT /sessions/{id} */
  UpdateSession(request: UpdateSessionRequest): Promise<UpdateSessionResponse>;
  /** PUT /sessions/{id}/studio */
  UpdateSessionStudio(request: UpdateSessionStudioRequest): Promise<UpdateSessionStudioResponse>;
  /** PUT /sessions/{id}/status */
  UpdateSessionStatus(request: UpdateSessionStatusRequest): Promise<UpdateSessionStatusResponse>;
  /** PUT /sessions/{id}/cancel */
  CancelSession(request: CancelSessionRequest): Promise<CancelSessionResponse>;
  /** POST /sessions/{id}/duplicate */
  DuplicateSession(request: DuplicateSessionRequest): Promise<DuplicateSessionResponse>;
  /**
   * Schedule & Location
   * PUT /sessions/{id}/entry-start-date
   */
  UpdateSessionEntryStartDate(
    request: UpdateSessionEntryStartDateRequest,
  ): Promise<UpdateSessionEntryStartDateResponse>;
  /** PUT /sessions/{id}/entry-end-date */
  UpdateSessionEntryEndDate(request: UpdateSessionEntryEndDateRequest): Promise<UpdateSessionEntryEndDateResponse>;
  /** PUT /sessions/{id}/schedule */
  UpdateSessionSchedule(request: UpdateSessionScheduleRequest): Promise<UpdateSessionScheduleResponse>;
  /** PUT /sessions/{id}/location */
  UpdateSessionLocation(request: UpdateSessionLocationRequest): Promise<UpdateSessionLocationResponse>;
  /**
   * Communication
   * POST /sessions/{id}/notifications
   */
  CreateSessionNotification(request: CreateSessionNotificationRequest): Promise<CreateSessionNotificationResponse>;
  /**
   * Related Sessions
   * GET /sessions/{id}/related-sessions
   */
  ListRelatedSessions(request: ListRelatedSessionsRequest): Promise<ListRelatedSessionsResponse>;
  /** POST /sessions/{id}/related-sessions */
  AddRelatedSession(request: AddRelatedSessionRequest): Promise<AddRelatedSessionResponse>;
}

export const SessionServiceServiceName = "bst.v1.SessionService";
export class SessionServiceClientImpl implements SessionService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || SessionServiceServiceName;
    this.rpc = rpc;
    this.CreateSession = this.CreateSession.bind(this);
    this.GetSession = this.GetSession.bind(this);
    this.UpdateSession = this.UpdateSession.bind(this);
    this.UpdateSessionStudio = this.UpdateSessionStudio.bind(this);
    this.UpdateSessionStatus = this.UpdateSessionStatus.bind(this);
    this.CancelSession = this.CancelSession.bind(this);
    this.DuplicateSession = this.DuplicateSession.bind(this);
    this.UpdateSessionEntryStartDate = this.UpdateSessionEntryStartDate.bind(this);
    this.UpdateSessionEntryEndDate = this.UpdateSessionEntryEndDate.bind(this);
    this.UpdateSessionSchedule = this.UpdateSessionSchedule.bind(this);
    this.UpdateSessionLocation = this.UpdateSessionLocation.bind(this);
    this.CreateSessionNotification = this.CreateSessionNotification.bind(this);
    this.ListRelatedSessions = this.ListRelatedSessions.bind(this);
    this.AddRelatedSession = this.AddRelatedSession.bind(this);
  }
  CreateSession(request: CreateSessionRequest): Promise<CreateSessionResponse> {
    const data = CreateSessionRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateSession", data);
    return promise.then((data) => CreateSessionResponse.decode(_m0.Reader.create(data)));
  }

  GetSession(request: GetSessionRequest): Promise<GetSessionResponse> {
    const data = GetSessionRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetSession", data);
    return promise.then((data) => GetSessionResponse.decode(_m0.Reader.create(data)));
  }

  UpdateSession(request: UpdateSessionRequest): Promise<UpdateSessionResponse> {
    const data = UpdateSessionRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateSession", data);
    return promise.then((data) => UpdateSessionResponse.decode(_m0.Reader.create(data)));
  }

  UpdateSessionStudio(request: UpdateSessionStudioRequest): Promise<UpdateSessionStudioResponse> {
    const data = UpdateSessionStudioRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateSessionStudio", data);
    return promise.then((data) => UpdateSessionStudioResponse.decode(_m0.Reader.create(data)));
  }

  UpdateSessionStatus(request: UpdateSessionStatusRequest): Promise<UpdateSessionStatusResponse> {
    const data = UpdateSessionStatusRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateSessionStatus", data);
    return promise.then((data) => UpdateSessionStatusResponse.decode(_m0.Reader.create(data)));
  }

  CancelSession(request: CancelSessionRequest): Promise<CancelSessionResponse> {
    const data = CancelSessionRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CancelSession", data);
    return promise.then((data) => CancelSessionResponse.decode(_m0.Reader.create(data)));
  }

  DuplicateSession(request: DuplicateSessionRequest): Promise<DuplicateSessionResponse> {
    const data = DuplicateSessionRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "DuplicateSession", data);
    return promise.then((data) => DuplicateSessionResponse.decode(_m0.Reader.create(data)));
  }

  UpdateSessionEntryStartDate(
    request: UpdateSessionEntryStartDateRequest,
  ): Promise<UpdateSessionEntryStartDateResponse> {
    const data = UpdateSessionEntryStartDateRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateSessionEntryStartDate", data);
    return promise.then((data) => UpdateSessionEntryStartDateResponse.decode(_m0.Reader.create(data)));
  }

  UpdateSessionEntryEndDate(request: UpdateSessionEntryEndDateRequest): Promise<UpdateSessionEntryEndDateResponse> {
    const data = UpdateSessionEntryEndDateRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateSessionEntryEndDate", data);
    return promise.then((data) => UpdateSessionEntryEndDateResponse.decode(_m0.Reader.create(data)));
  }

  UpdateSessionSchedule(request: UpdateSessionScheduleRequest): Promise<UpdateSessionScheduleResponse> {
    const data = UpdateSessionScheduleRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateSessionSchedule", data);
    return promise.then((data) => UpdateSessionScheduleResponse.decode(_m0.Reader.create(data)));
  }

  UpdateSessionLocation(request: UpdateSessionLocationRequest): Promise<UpdateSessionLocationResponse> {
    const data = UpdateSessionLocationRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateSessionLocation", data);
    return promise.then((data) => UpdateSessionLocationResponse.decode(_m0.Reader.create(data)));
  }

  CreateSessionNotification(request: CreateSessionNotificationRequest): Promise<CreateSessionNotificationResponse> {
    const data = CreateSessionNotificationRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateSessionNotification", data);
    return promise.then((data) => CreateSessionNotificationResponse.decode(_m0.Reader.create(data)));
  }

  ListRelatedSessions(request: ListRelatedSessionsRequest): Promise<ListRelatedSessionsResponse> {
    const data = ListRelatedSessionsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListRelatedSessions", data);
    return promise.then((data) => ListRelatedSessionsResponse.decode(_m0.Reader.create(data)));
  }

  AddRelatedSession(request: AddRelatedSessionRequest): Promise<AddRelatedSessionResponse> {
    const data = AddRelatedSessionRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "AddRelatedSession", data);
    return promise.then((data) => AddRelatedSessionResponse.decode(_m0.Reader.create(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
