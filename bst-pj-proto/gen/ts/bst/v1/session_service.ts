// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v5.29.3
// source: bst/v1/session_service.proto

/* eslint-disable */
import _m0 from "protobufjs/minimal";
import { Timestamp } from "../../google/protobuf/timestamp";
import { Thread } from "./communication";
import { Resource } from "./content";
import { Location } from "./location";
import {
  Session,
  SessionDetail,
  SessionFeedback,
  SessionParticipant,
  SessionStatus,
  sessionStatusFromJSON,
  sessionStatusToJSON,
  SongPerformanceEntry,
  Timetable,
  TimetableEntry,
} from "./session";

export const protobufPackage = "bst.v1";

/** Session Management */
export interface CreateSessionRequest {
  title: string;
  description: string;
  eventDate: Date | undefined;
}

export interface CreateSessionResponse {
  session: Session | undefined;
}

export interface GetSessionRequest {
  sessionId: number;
}

export interface GetSessionResponse {
  session: SessionDetail | undefined;
}

export interface UpdateSessionRequest {
  sessionId: number;
  title: string;
  description: string;
  eventDate: Date | undefined;
}

export interface UpdateSessionResponse {
  session: SessionDetail | undefined;
}

export interface UpdateSessionStatusRequest {
  sessionId: number;
  status: SessionStatus;
}

export interface UpdateSessionStatusResponse {
  session: SessionDetail | undefined;
}

export interface CancelSessionRequest {
  sessionId: number;
  reason: string;
}

export interface CancelSessionResponse {
  session: SessionDetail | undefined;
}

export interface DuplicateSessionRequest {
  sessionId: number;
  newEventDate: Date | undefined;
}

export interface DuplicateSessionResponse {
  session: SessionDetail | undefined;
}

/** Schedule & Location */
export interface UpdateSessionScheduleRequest {
  sessionId: number;
  timetable: Timetable | undefined;
}

export interface UpdateSessionScheduleResponse {
  timetable: Timetable | undefined;
}

export interface UpdateSessionLocationRequest {
  sessionId: number;
  location: Location | undefined;
}

export interface UpdateSessionLocationResponse {
  location: Location | undefined;
}

/** Participants */
export interface ListSessionParticipantsRequest {
  sessionId: number;
}

export interface ListSessionParticipantsResponse {
  participants: SessionParticipant[];
}

export interface AddSessionParticipantRequest {
  sessionId: number;
  participant: SessionParticipant | undefined;
}

export interface AddSessionParticipantResponse {
  participant: SessionParticipant | undefined;
}

export interface UpdateSessionParticipantRequest {
  sessionId: number;
  participantId: number;
  participant: SessionParticipant | undefined;
}

export interface UpdateSessionParticipantResponse {
  participant: SessionParticipant | undefined;
}

/** Song Entries */
export interface AddSongEntryRequest {
  sessionId: number;
  songId: number;
  entry: SongPerformanceEntry | undefined;
}

export interface AddSongEntryResponse {
  entry: SongPerformanceEntry | undefined;
}

export interface DeleteSongEntryRequest {
  sessionId: number;
  songId: number;
  entryId: number;
}

export interface DeleteSongEntryResponse {
  success: boolean;
}

/** Song Resources */
export interface AddSessionSongResourceRequest {
  sessionId: number;
  songId: number;
  resource: Resource | undefined;
}

export interface AddSessionSongResourceResponse {
  resource: Resource | undefined;
}

export interface ListSessionSongResourcesRequest {
  sessionId: number;
  songId: number;
}

export interface ListSessionSongResourcesResponse {
  resources: Resource[];
  nextPageToken: string;
  totalSize: number;
}

export interface DeleteSessionSongResourceRequest {
  sessionId: number;
  songId: number;
  resourceId: number;
}

export interface DeleteSessionSongResourceResponse {
  success: boolean;
}

/** Organizers */
export interface ListSessionOrganizersRequest {
  sessionId: number;
}

export interface ListSessionOrganizersResponse {
  organizers: SessionParticipant[];
}

export interface AddSessionOrganizerRequest {
  sessionId: number;
  userId: number;
}

export interface AddSessionOrganizerResponse {
  organizer: SessionParticipant | undefined;
}

export interface DeleteSessionOrganizerRequest {
  sessionId: number;
  userId: number;
}

export interface DeleteSessionOrganizerResponse {
  success: boolean;
}

/** Communication */
export interface CreateSessionThreadRequest {
  sessionId: number;
  thread: Thread | undefined;
}

export interface CreateSessionThreadResponse {
  thread: Thread | undefined;
}

export interface ListSessionThreadsRequest {
  sessionId: number;
}

export interface ListSessionThreadsResponse {
  threads: Thread[];
}

export interface CreateSongThreadRequest {
  sessionId: number;
  songId: number;
  thread: Thread | undefined;
}

export interface CreateSongThreadResponse {
  thread: Thread | undefined;
}

export interface GetSessionThreadRequest {
  sessionId: number;
  threadId: number;
}

export interface GetSessionThreadResponse {
  thread: Thread | undefined;
}

export interface DeleteSessionThreadRequest {
  sessionId: number;
  threadId: number;
}

export interface DeleteSessionThreadResponse {
  success: boolean;
}

export interface CreateSessionNotificationRequest {
  sessionId: number;
  content: string;
  userIds: number[];
}

export interface CreateSessionNotificationResponse {
  success: boolean;
}

/** Timetable */
export interface GetSessionTimetableRequest {
  sessionId: number;
}

export interface GetSessionTimetableResponse {
  timetable: Timetable | undefined;
}

export interface UpdateSessionTimetableRequest {
  sessionId: number;
  timetable: Timetable | undefined;
}

export interface UpdateSessionTimetableResponse {
  timetable: Timetable | undefined;
}

export interface GetOptimizedTimetableRequest {
  sessionId: number;
  optimizationRules: string[];
}

export interface GetOptimizedTimetableResponse {
  timetable: Timetable | undefined;
}

export interface GetTimetableProgressRequest {
  sessionId: number;
}

export interface GetTimetableProgressResponse {
  completedEntries: TimetableEntry[];
  currentEntry: TimetableEntry | undefined;
}

export interface UpdateTimetableProgressRequest {
  sessionId: number;
  currentEntryId: number;
}

export interface UpdateTimetableProgressResponse {
  success: boolean;
}

/** Session Resources */
export interface AddSessionResourceRequest {
  sessionId: number;
  resource: Resource | undefined;
}

export interface AddSessionResourceResponse {
  resource: Resource | undefined;
}

export interface ListSessionResourcesRequest {
  sessionId: number;
}

export interface ListSessionResourcesResponse {
  resources: Resource[];
}

export interface DeleteSessionResourceRequest {
  sessionId: number;
  resourceId: number;
}

export interface DeleteSessionResourceResponse {
  success: boolean;
}

/** Ratings */
export interface AddSessionFeedbackRequest {
  feedback: SessionFeedback | undefined;
}

export interface AddSessionFeedbackResponse {
  success: boolean;
}

export interface ListSessionFeedbacksRequest {
  sessionId: number;
}

export interface ListSessionFeedbacksResponse {
  feedbacks: SessionFeedback[];
}

/** Related Sessions */
export interface ListRelatedSessionsRequest {
  sessionId: number;
}

export interface ListRelatedSessionsResponse {
  sessions: Session[];
}

export interface AddRelatedSessionRequest {
  sessionId: number;
  relatedSessionId: number;
}

export interface AddRelatedSessionResponse {
  success: boolean;
}

function createBaseCreateSessionRequest(): CreateSessionRequest {
  return { title: "", description: "", eventDate: undefined };
}

export const CreateSessionRequest = {
  encode(message: CreateSessionRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.eventDate !== undefined) {
      Timestamp.encode(toTimestamp(message.eventDate), writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateSessionRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.title = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.eventDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSessionRequest {
    return {
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      eventDate: isSet(object.eventDate) ? fromJsonTimestamp(object.eventDate) : undefined,
    };
  },

  toJSON(message: CreateSessionRequest): unknown {
    const obj: any = {};
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.eventDate !== undefined) {
      obj.eventDate = message.eventDate.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateSessionRequest>, I>>(base?: I): CreateSessionRequest {
    return CreateSessionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateSessionRequest>, I>>(object: I): CreateSessionRequest {
    const message = createBaseCreateSessionRequest();
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.eventDate = object.eventDate ?? undefined;
    return message;
  },
};

function createBaseCreateSessionResponse(): CreateSessionResponse {
  return { session: undefined };
}

export const CreateSessionResponse = {
  encode(message: CreateSessionResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.session !== undefined) {
      Session.encode(message.session, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateSessionResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.session = Session.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSessionResponse {
    return { session: isSet(object.session) ? Session.fromJSON(object.session) : undefined };
  },

  toJSON(message: CreateSessionResponse): unknown {
    const obj: any = {};
    if (message.session !== undefined) {
      obj.session = Session.toJSON(message.session);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateSessionResponse>, I>>(base?: I): CreateSessionResponse {
    return CreateSessionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateSessionResponse>, I>>(object: I): CreateSessionResponse {
    const message = createBaseCreateSessionResponse();
    message.session = (object.session !== undefined && object.session !== null)
      ? Session.fromPartial(object.session)
      : undefined;
    return message;
  },
};

function createBaseGetSessionRequest(): GetSessionRequest {
  return { sessionId: 0 };
}

export const GetSessionRequest = {
  encode(message: GetSessionRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== 0) {
      writer.uint32(8).int32(message.sessionId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetSessionRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sessionId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSessionRequest {
    return { sessionId: isSet(object.sessionId) ? globalThis.Number(object.sessionId) : 0 };
  },

  toJSON(message: GetSessionRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== 0) {
      obj.sessionId = Math.round(message.sessionId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSessionRequest>, I>>(base?: I): GetSessionRequest {
    return GetSessionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSessionRequest>, I>>(object: I): GetSessionRequest {
    const message = createBaseGetSessionRequest();
    message.sessionId = object.sessionId ?? 0;
    return message;
  },
};

function createBaseGetSessionResponse(): GetSessionResponse {
  return { session: undefined };
}

export const GetSessionResponse = {
  encode(message: GetSessionResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.session !== undefined) {
      SessionDetail.encode(message.session, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetSessionResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.session = SessionDetail.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSessionResponse {
    return { session: isSet(object.session) ? SessionDetail.fromJSON(object.session) : undefined };
  },

  toJSON(message: GetSessionResponse): unknown {
    const obj: any = {};
    if (message.session !== undefined) {
      obj.session = SessionDetail.toJSON(message.session);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSessionResponse>, I>>(base?: I): GetSessionResponse {
    return GetSessionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSessionResponse>, I>>(object: I): GetSessionResponse {
    const message = createBaseGetSessionResponse();
    message.session = (object.session !== undefined && object.session !== null)
      ? SessionDetail.fromPartial(object.session)
      : undefined;
    return message;
  },
};

function createBaseUpdateSessionRequest(): UpdateSessionRequest {
  return { sessionId: 0, title: "", description: "", eventDate: undefined };
}

export const UpdateSessionRequest = {
  encode(message: UpdateSessionRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== 0) {
      writer.uint32(8).int32(message.sessionId);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.eventDate !== undefined) {
      Timestamp.encode(toTimestamp(message.eventDate), writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateSessionRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sessionId = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.eventDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateSessionRequest {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.Number(object.sessionId) : 0,
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      eventDate: isSet(object.eventDate) ? fromJsonTimestamp(object.eventDate) : undefined,
    };
  },

  toJSON(message: UpdateSessionRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== 0) {
      obj.sessionId = Math.round(message.sessionId);
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.eventDate !== undefined) {
      obj.eventDate = message.eventDate.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateSessionRequest>, I>>(base?: I): UpdateSessionRequest {
    return UpdateSessionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateSessionRequest>, I>>(object: I): UpdateSessionRequest {
    const message = createBaseUpdateSessionRequest();
    message.sessionId = object.sessionId ?? 0;
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.eventDate = object.eventDate ?? undefined;
    return message;
  },
};

function createBaseUpdateSessionResponse(): UpdateSessionResponse {
  return { session: undefined };
}

export const UpdateSessionResponse = {
  encode(message: UpdateSessionResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.session !== undefined) {
      SessionDetail.encode(message.session, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateSessionResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.session = SessionDetail.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateSessionResponse {
    return { session: isSet(object.session) ? SessionDetail.fromJSON(object.session) : undefined };
  },

  toJSON(message: UpdateSessionResponse): unknown {
    const obj: any = {};
    if (message.session !== undefined) {
      obj.session = SessionDetail.toJSON(message.session);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateSessionResponse>, I>>(base?: I): UpdateSessionResponse {
    return UpdateSessionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateSessionResponse>, I>>(object: I): UpdateSessionResponse {
    const message = createBaseUpdateSessionResponse();
    message.session = (object.session !== undefined && object.session !== null)
      ? SessionDetail.fromPartial(object.session)
      : undefined;
    return message;
  },
};

function createBaseUpdateSessionStatusRequest(): UpdateSessionStatusRequest {
  return { sessionId: 0, status: 0 };
}

export const UpdateSessionStatusRequest = {
  encode(message: UpdateSessionStatusRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== 0) {
      writer.uint32(8).int32(message.sessionId);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateSessionStatusRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSessionStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sessionId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateSessionStatusRequest {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.Number(object.sessionId) : 0,
      status: isSet(object.status) ? sessionStatusFromJSON(object.status) : 0,
    };
  },

  toJSON(message: UpdateSessionStatusRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== 0) {
      obj.sessionId = Math.round(message.sessionId);
    }
    if (message.status !== 0) {
      obj.status = sessionStatusToJSON(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateSessionStatusRequest>, I>>(base?: I): UpdateSessionStatusRequest {
    return UpdateSessionStatusRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateSessionStatusRequest>, I>>(object: I): UpdateSessionStatusRequest {
    const message = createBaseUpdateSessionStatusRequest();
    message.sessionId = object.sessionId ?? 0;
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseUpdateSessionStatusResponse(): UpdateSessionStatusResponse {
  return { session: undefined };
}

export const UpdateSessionStatusResponse = {
  encode(message: UpdateSessionStatusResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.session !== undefined) {
      SessionDetail.encode(message.session, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateSessionStatusResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSessionStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.session = SessionDetail.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateSessionStatusResponse {
    return { session: isSet(object.session) ? SessionDetail.fromJSON(object.session) : undefined };
  },

  toJSON(message: UpdateSessionStatusResponse): unknown {
    const obj: any = {};
    if (message.session !== undefined) {
      obj.session = SessionDetail.toJSON(message.session);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateSessionStatusResponse>, I>>(base?: I): UpdateSessionStatusResponse {
    return UpdateSessionStatusResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateSessionStatusResponse>, I>>(object: I): UpdateSessionStatusResponse {
    const message = createBaseUpdateSessionStatusResponse();
    message.session = (object.session !== undefined && object.session !== null)
      ? SessionDetail.fromPartial(object.session)
      : undefined;
    return message;
  },
};

function createBaseCancelSessionRequest(): CancelSessionRequest {
  return { sessionId: 0, reason: "" };
}

export const CancelSessionRequest = {
  encode(message: CancelSessionRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== 0) {
      writer.uint32(8).int32(message.sessionId);
    }
    if (message.reason !== "") {
      writer.uint32(18).string(message.reason);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CancelSessionRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sessionId = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.reason = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelSessionRequest {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.Number(object.sessionId) : 0,
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
    };
  },

  toJSON(message: CancelSessionRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== 0) {
      obj.sessionId = Math.round(message.sessionId);
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CancelSessionRequest>, I>>(base?: I): CancelSessionRequest {
    return CancelSessionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CancelSessionRequest>, I>>(object: I): CancelSessionRequest {
    const message = createBaseCancelSessionRequest();
    message.sessionId = object.sessionId ?? 0;
    message.reason = object.reason ?? "";
    return message;
  },
};

function createBaseCancelSessionResponse(): CancelSessionResponse {
  return { session: undefined };
}

export const CancelSessionResponse = {
  encode(message: CancelSessionResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.session !== undefined) {
      SessionDetail.encode(message.session, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CancelSessionResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.session = SessionDetail.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelSessionResponse {
    return { session: isSet(object.session) ? SessionDetail.fromJSON(object.session) : undefined };
  },

  toJSON(message: CancelSessionResponse): unknown {
    const obj: any = {};
    if (message.session !== undefined) {
      obj.session = SessionDetail.toJSON(message.session);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CancelSessionResponse>, I>>(base?: I): CancelSessionResponse {
    return CancelSessionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CancelSessionResponse>, I>>(object: I): CancelSessionResponse {
    const message = createBaseCancelSessionResponse();
    message.session = (object.session !== undefined && object.session !== null)
      ? SessionDetail.fromPartial(object.session)
      : undefined;
    return message;
  },
};

function createBaseDuplicateSessionRequest(): DuplicateSessionRequest {
  return { sessionId: 0, newEventDate: undefined };
}

export const DuplicateSessionRequest = {
  encode(message: DuplicateSessionRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== 0) {
      writer.uint32(8).int32(message.sessionId);
    }
    if (message.newEventDate !== undefined) {
      Timestamp.encode(toTimestamp(message.newEventDate), writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DuplicateSessionRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDuplicateSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sessionId = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.newEventDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DuplicateSessionRequest {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.Number(object.sessionId) : 0,
      newEventDate: isSet(object.newEventDate) ? fromJsonTimestamp(object.newEventDate) : undefined,
    };
  },

  toJSON(message: DuplicateSessionRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== 0) {
      obj.sessionId = Math.round(message.sessionId);
    }
    if (message.newEventDate !== undefined) {
      obj.newEventDate = message.newEventDate.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DuplicateSessionRequest>, I>>(base?: I): DuplicateSessionRequest {
    return DuplicateSessionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DuplicateSessionRequest>, I>>(object: I): DuplicateSessionRequest {
    const message = createBaseDuplicateSessionRequest();
    message.sessionId = object.sessionId ?? 0;
    message.newEventDate = object.newEventDate ?? undefined;
    return message;
  },
};

function createBaseDuplicateSessionResponse(): DuplicateSessionResponse {
  return { session: undefined };
}

export const DuplicateSessionResponse = {
  encode(message: DuplicateSessionResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.session !== undefined) {
      SessionDetail.encode(message.session, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DuplicateSessionResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDuplicateSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.session = SessionDetail.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DuplicateSessionResponse {
    return { session: isSet(object.session) ? SessionDetail.fromJSON(object.session) : undefined };
  },

  toJSON(message: DuplicateSessionResponse): unknown {
    const obj: any = {};
    if (message.session !== undefined) {
      obj.session = SessionDetail.toJSON(message.session);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DuplicateSessionResponse>, I>>(base?: I): DuplicateSessionResponse {
    return DuplicateSessionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DuplicateSessionResponse>, I>>(object: I): DuplicateSessionResponse {
    const message = createBaseDuplicateSessionResponse();
    message.session = (object.session !== undefined && object.session !== null)
      ? SessionDetail.fromPartial(object.session)
      : undefined;
    return message;
  },
};

function createBaseUpdateSessionScheduleRequest(): UpdateSessionScheduleRequest {
  return { sessionId: 0, timetable: undefined };
}

export const UpdateSessionScheduleRequest = {
  encode(message: UpdateSessionScheduleRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== 0) {
      writer.uint32(8).int32(message.sessionId);
    }
    if (message.timetable !== undefined) {
      Timetable.encode(message.timetable, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateSessionScheduleRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSessionScheduleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sessionId = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.timetable = Timetable.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateSessionScheduleRequest {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.Number(object.sessionId) : 0,
      timetable: isSet(object.timetable) ? Timetable.fromJSON(object.timetable) : undefined,
    };
  },

  toJSON(message: UpdateSessionScheduleRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== 0) {
      obj.sessionId = Math.round(message.sessionId);
    }
    if (message.timetable !== undefined) {
      obj.timetable = Timetable.toJSON(message.timetable);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateSessionScheduleRequest>, I>>(base?: I): UpdateSessionScheduleRequest {
    return UpdateSessionScheduleRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateSessionScheduleRequest>, I>>(object: I): UpdateSessionScheduleRequest {
    const message = createBaseUpdateSessionScheduleRequest();
    message.sessionId = object.sessionId ?? 0;
    message.timetable = (object.timetable !== undefined && object.timetable !== null)
      ? Timetable.fromPartial(object.timetable)
      : undefined;
    return message;
  },
};

function createBaseUpdateSessionScheduleResponse(): UpdateSessionScheduleResponse {
  return { timetable: undefined };
}

export const UpdateSessionScheduleResponse = {
  encode(message: UpdateSessionScheduleResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.timetable !== undefined) {
      Timetable.encode(message.timetable, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateSessionScheduleResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSessionScheduleResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.timetable = Timetable.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateSessionScheduleResponse {
    return { timetable: isSet(object.timetable) ? Timetable.fromJSON(object.timetable) : undefined };
  },

  toJSON(message: UpdateSessionScheduleResponse): unknown {
    const obj: any = {};
    if (message.timetable !== undefined) {
      obj.timetable = Timetable.toJSON(message.timetable);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateSessionScheduleResponse>, I>>(base?: I): UpdateSessionScheduleResponse {
    return UpdateSessionScheduleResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateSessionScheduleResponse>, I>>(
    object: I,
  ): UpdateSessionScheduleResponse {
    const message = createBaseUpdateSessionScheduleResponse();
    message.timetable = (object.timetable !== undefined && object.timetable !== null)
      ? Timetable.fromPartial(object.timetable)
      : undefined;
    return message;
  },
};

function createBaseUpdateSessionLocationRequest(): UpdateSessionLocationRequest {
  return { sessionId: 0, location: undefined };
}

export const UpdateSessionLocationRequest = {
  encode(message: UpdateSessionLocationRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== 0) {
      writer.uint32(8).int32(message.sessionId);
    }
    if (message.location !== undefined) {
      Location.encode(message.location, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateSessionLocationRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSessionLocationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sessionId = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.location = Location.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateSessionLocationRequest {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.Number(object.sessionId) : 0,
      location: isSet(object.location) ? Location.fromJSON(object.location) : undefined,
    };
  },

  toJSON(message: UpdateSessionLocationRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== 0) {
      obj.sessionId = Math.round(message.sessionId);
    }
    if (message.location !== undefined) {
      obj.location = Location.toJSON(message.location);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateSessionLocationRequest>, I>>(base?: I): UpdateSessionLocationRequest {
    return UpdateSessionLocationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateSessionLocationRequest>, I>>(object: I): UpdateSessionLocationRequest {
    const message = createBaseUpdateSessionLocationRequest();
    message.sessionId = object.sessionId ?? 0;
    message.location = (object.location !== undefined && object.location !== null)
      ? Location.fromPartial(object.location)
      : undefined;
    return message;
  },
};

function createBaseUpdateSessionLocationResponse(): UpdateSessionLocationResponse {
  return { location: undefined };
}

export const UpdateSessionLocationResponse = {
  encode(message: UpdateSessionLocationResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.location !== undefined) {
      Location.encode(message.location, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateSessionLocationResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSessionLocationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.location = Location.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateSessionLocationResponse {
    return { location: isSet(object.location) ? Location.fromJSON(object.location) : undefined };
  },

  toJSON(message: UpdateSessionLocationResponse): unknown {
    const obj: any = {};
    if (message.location !== undefined) {
      obj.location = Location.toJSON(message.location);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateSessionLocationResponse>, I>>(base?: I): UpdateSessionLocationResponse {
    return UpdateSessionLocationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateSessionLocationResponse>, I>>(
    object: I,
  ): UpdateSessionLocationResponse {
    const message = createBaseUpdateSessionLocationResponse();
    message.location = (object.location !== undefined && object.location !== null)
      ? Location.fromPartial(object.location)
      : undefined;
    return message;
  },
};

function createBaseListSessionParticipantsRequest(): ListSessionParticipantsRequest {
  return { sessionId: 0 };
}

export const ListSessionParticipantsRequest = {
  encode(message: ListSessionParticipantsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== 0) {
      writer.uint32(8).int32(message.sessionId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListSessionParticipantsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSessionParticipantsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sessionId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSessionParticipantsRequest {
    return { sessionId: isSet(object.sessionId) ? globalThis.Number(object.sessionId) : 0 };
  },

  toJSON(message: ListSessionParticipantsRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== 0) {
      obj.sessionId = Math.round(message.sessionId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListSessionParticipantsRequest>, I>>(base?: I): ListSessionParticipantsRequest {
    return ListSessionParticipantsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListSessionParticipantsRequest>, I>>(
    object: I,
  ): ListSessionParticipantsRequest {
    const message = createBaseListSessionParticipantsRequest();
    message.sessionId = object.sessionId ?? 0;
    return message;
  },
};

function createBaseListSessionParticipantsResponse(): ListSessionParticipantsResponse {
  return { participants: [] };
}

export const ListSessionParticipantsResponse = {
  encode(message: ListSessionParticipantsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.participants) {
      SessionParticipant.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListSessionParticipantsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSessionParticipantsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.participants.push(SessionParticipant.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSessionParticipantsResponse {
    return {
      participants: globalThis.Array.isArray(object?.participants)
        ? object.participants.map((e: any) => SessionParticipant.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListSessionParticipantsResponse): unknown {
    const obj: any = {};
    if (message.participants?.length) {
      obj.participants = message.participants.map((e) => SessionParticipant.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListSessionParticipantsResponse>, I>>(base?: I): ListSessionParticipantsResponse {
    return ListSessionParticipantsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListSessionParticipantsResponse>, I>>(
    object: I,
  ): ListSessionParticipantsResponse {
    const message = createBaseListSessionParticipantsResponse();
    message.participants = object.participants?.map((e) => SessionParticipant.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAddSessionParticipantRequest(): AddSessionParticipantRequest {
  return { sessionId: 0, participant: undefined };
}

export const AddSessionParticipantRequest = {
  encode(message: AddSessionParticipantRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== 0) {
      writer.uint32(8).int32(message.sessionId);
    }
    if (message.participant !== undefined) {
      SessionParticipant.encode(message.participant, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AddSessionParticipantRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddSessionParticipantRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sessionId = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.participant = SessionParticipant.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddSessionParticipantRequest {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.Number(object.sessionId) : 0,
      participant: isSet(object.participant) ? SessionParticipant.fromJSON(object.participant) : undefined,
    };
  },

  toJSON(message: AddSessionParticipantRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== 0) {
      obj.sessionId = Math.round(message.sessionId);
    }
    if (message.participant !== undefined) {
      obj.participant = SessionParticipant.toJSON(message.participant);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddSessionParticipantRequest>, I>>(base?: I): AddSessionParticipantRequest {
    return AddSessionParticipantRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddSessionParticipantRequest>, I>>(object: I): AddSessionParticipantRequest {
    const message = createBaseAddSessionParticipantRequest();
    message.sessionId = object.sessionId ?? 0;
    message.participant = (object.participant !== undefined && object.participant !== null)
      ? SessionParticipant.fromPartial(object.participant)
      : undefined;
    return message;
  },
};

function createBaseAddSessionParticipantResponse(): AddSessionParticipantResponse {
  return { participant: undefined };
}

export const AddSessionParticipantResponse = {
  encode(message: AddSessionParticipantResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.participant !== undefined) {
      SessionParticipant.encode(message.participant, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AddSessionParticipantResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddSessionParticipantResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.participant = SessionParticipant.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddSessionParticipantResponse {
    return { participant: isSet(object.participant) ? SessionParticipant.fromJSON(object.participant) : undefined };
  },

  toJSON(message: AddSessionParticipantResponse): unknown {
    const obj: any = {};
    if (message.participant !== undefined) {
      obj.participant = SessionParticipant.toJSON(message.participant);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddSessionParticipantResponse>, I>>(base?: I): AddSessionParticipantResponse {
    return AddSessionParticipantResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddSessionParticipantResponse>, I>>(
    object: I,
  ): AddSessionParticipantResponse {
    const message = createBaseAddSessionParticipantResponse();
    message.participant = (object.participant !== undefined && object.participant !== null)
      ? SessionParticipant.fromPartial(object.participant)
      : undefined;
    return message;
  },
};

function createBaseUpdateSessionParticipantRequest(): UpdateSessionParticipantRequest {
  return { sessionId: 0, participantId: 0, participant: undefined };
}

export const UpdateSessionParticipantRequest = {
  encode(message: UpdateSessionParticipantRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== 0) {
      writer.uint32(8).int32(message.sessionId);
    }
    if (message.participantId !== 0) {
      writer.uint32(16).int32(message.participantId);
    }
    if (message.participant !== undefined) {
      SessionParticipant.encode(message.participant, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateSessionParticipantRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSessionParticipantRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sessionId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.participantId = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.participant = SessionParticipant.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateSessionParticipantRequest {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.Number(object.sessionId) : 0,
      participantId: isSet(object.participantId) ? globalThis.Number(object.participantId) : 0,
      participant: isSet(object.participant) ? SessionParticipant.fromJSON(object.participant) : undefined,
    };
  },

  toJSON(message: UpdateSessionParticipantRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== 0) {
      obj.sessionId = Math.round(message.sessionId);
    }
    if (message.participantId !== 0) {
      obj.participantId = Math.round(message.participantId);
    }
    if (message.participant !== undefined) {
      obj.participant = SessionParticipant.toJSON(message.participant);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateSessionParticipantRequest>, I>>(base?: I): UpdateSessionParticipantRequest {
    return UpdateSessionParticipantRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateSessionParticipantRequest>, I>>(
    object: I,
  ): UpdateSessionParticipantRequest {
    const message = createBaseUpdateSessionParticipantRequest();
    message.sessionId = object.sessionId ?? 0;
    message.participantId = object.participantId ?? 0;
    message.participant = (object.participant !== undefined && object.participant !== null)
      ? SessionParticipant.fromPartial(object.participant)
      : undefined;
    return message;
  },
};

function createBaseUpdateSessionParticipantResponse(): UpdateSessionParticipantResponse {
  return { participant: undefined };
}

export const UpdateSessionParticipantResponse = {
  encode(message: UpdateSessionParticipantResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.participant !== undefined) {
      SessionParticipant.encode(message.participant, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateSessionParticipantResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSessionParticipantResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.participant = SessionParticipant.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateSessionParticipantResponse {
    return { participant: isSet(object.participant) ? SessionParticipant.fromJSON(object.participant) : undefined };
  },

  toJSON(message: UpdateSessionParticipantResponse): unknown {
    const obj: any = {};
    if (message.participant !== undefined) {
      obj.participant = SessionParticipant.toJSON(message.participant);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateSessionParticipantResponse>, I>>(
    base?: I,
  ): UpdateSessionParticipantResponse {
    return UpdateSessionParticipantResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateSessionParticipantResponse>, I>>(
    object: I,
  ): UpdateSessionParticipantResponse {
    const message = createBaseUpdateSessionParticipantResponse();
    message.participant = (object.participant !== undefined && object.participant !== null)
      ? SessionParticipant.fromPartial(object.participant)
      : undefined;
    return message;
  },
};

function createBaseAddSongEntryRequest(): AddSongEntryRequest {
  return { sessionId: 0, songId: 0, entry: undefined };
}

export const AddSongEntryRequest = {
  encode(message: AddSongEntryRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== 0) {
      writer.uint32(8).int32(message.sessionId);
    }
    if (message.songId !== 0) {
      writer.uint32(16).int32(message.songId);
    }
    if (message.entry !== undefined) {
      SongPerformanceEntry.encode(message.entry, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AddSongEntryRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddSongEntryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sessionId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.songId = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.entry = SongPerformanceEntry.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddSongEntryRequest {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.Number(object.sessionId) : 0,
      songId: isSet(object.songId) ? globalThis.Number(object.songId) : 0,
      entry: isSet(object.entry) ? SongPerformanceEntry.fromJSON(object.entry) : undefined,
    };
  },

  toJSON(message: AddSongEntryRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== 0) {
      obj.sessionId = Math.round(message.sessionId);
    }
    if (message.songId !== 0) {
      obj.songId = Math.round(message.songId);
    }
    if (message.entry !== undefined) {
      obj.entry = SongPerformanceEntry.toJSON(message.entry);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddSongEntryRequest>, I>>(base?: I): AddSongEntryRequest {
    return AddSongEntryRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddSongEntryRequest>, I>>(object: I): AddSongEntryRequest {
    const message = createBaseAddSongEntryRequest();
    message.sessionId = object.sessionId ?? 0;
    message.songId = object.songId ?? 0;
    message.entry = (object.entry !== undefined && object.entry !== null)
      ? SongPerformanceEntry.fromPartial(object.entry)
      : undefined;
    return message;
  },
};

function createBaseAddSongEntryResponse(): AddSongEntryResponse {
  return { entry: undefined };
}

export const AddSongEntryResponse = {
  encode(message: AddSongEntryResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.entry !== undefined) {
      SongPerformanceEntry.encode(message.entry, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AddSongEntryResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddSongEntryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entry = SongPerformanceEntry.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddSongEntryResponse {
    return { entry: isSet(object.entry) ? SongPerformanceEntry.fromJSON(object.entry) : undefined };
  },

  toJSON(message: AddSongEntryResponse): unknown {
    const obj: any = {};
    if (message.entry !== undefined) {
      obj.entry = SongPerformanceEntry.toJSON(message.entry);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddSongEntryResponse>, I>>(base?: I): AddSongEntryResponse {
    return AddSongEntryResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddSongEntryResponse>, I>>(object: I): AddSongEntryResponse {
    const message = createBaseAddSongEntryResponse();
    message.entry = (object.entry !== undefined && object.entry !== null)
      ? SongPerformanceEntry.fromPartial(object.entry)
      : undefined;
    return message;
  },
};

function createBaseDeleteSongEntryRequest(): DeleteSongEntryRequest {
  return { sessionId: 0, songId: 0, entryId: 0 };
}

export const DeleteSongEntryRequest = {
  encode(message: DeleteSongEntryRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== 0) {
      writer.uint32(8).int32(message.sessionId);
    }
    if (message.songId !== 0) {
      writer.uint32(16).int32(message.songId);
    }
    if (message.entryId !== 0) {
      writer.uint32(24).int32(message.entryId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteSongEntryRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteSongEntryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sessionId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.songId = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.entryId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteSongEntryRequest {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.Number(object.sessionId) : 0,
      songId: isSet(object.songId) ? globalThis.Number(object.songId) : 0,
      entryId: isSet(object.entryId) ? globalThis.Number(object.entryId) : 0,
    };
  },

  toJSON(message: DeleteSongEntryRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== 0) {
      obj.sessionId = Math.round(message.sessionId);
    }
    if (message.songId !== 0) {
      obj.songId = Math.round(message.songId);
    }
    if (message.entryId !== 0) {
      obj.entryId = Math.round(message.entryId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteSongEntryRequest>, I>>(base?: I): DeleteSongEntryRequest {
    return DeleteSongEntryRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteSongEntryRequest>, I>>(object: I): DeleteSongEntryRequest {
    const message = createBaseDeleteSongEntryRequest();
    message.sessionId = object.sessionId ?? 0;
    message.songId = object.songId ?? 0;
    message.entryId = object.entryId ?? 0;
    return message;
  },
};

function createBaseDeleteSongEntryResponse(): DeleteSongEntryResponse {
  return { success: false };
}

export const DeleteSongEntryResponse = {
  encode(message: DeleteSongEntryResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteSongEntryResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteSongEntryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteSongEntryResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: DeleteSongEntryResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteSongEntryResponse>, I>>(base?: I): DeleteSongEntryResponse {
    return DeleteSongEntryResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteSongEntryResponse>, I>>(object: I): DeleteSongEntryResponse {
    const message = createBaseDeleteSongEntryResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseAddSessionSongResourceRequest(): AddSessionSongResourceRequest {
  return { sessionId: 0, songId: 0, resource: undefined };
}

export const AddSessionSongResourceRequest = {
  encode(message: AddSessionSongResourceRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== 0) {
      writer.uint32(8).int32(message.sessionId);
    }
    if (message.songId !== 0) {
      writer.uint32(16).int32(message.songId);
    }
    if (message.resource !== undefined) {
      Resource.encode(message.resource, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AddSessionSongResourceRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddSessionSongResourceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sessionId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.songId = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.resource = Resource.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddSessionSongResourceRequest {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.Number(object.sessionId) : 0,
      songId: isSet(object.songId) ? globalThis.Number(object.songId) : 0,
      resource: isSet(object.resource) ? Resource.fromJSON(object.resource) : undefined,
    };
  },

  toJSON(message: AddSessionSongResourceRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== 0) {
      obj.sessionId = Math.round(message.sessionId);
    }
    if (message.songId !== 0) {
      obj.songId = Math.round(message.songId);
    }
    if (message.resource !== undefined) {
      obj.resource = Resource.toJSON(message.resource);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddSessionSongResourceRequest>, I>>(base?: I): AddSessionSongResourceRequest {
    return AddSessionSongResourceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddSessionSongResourceRequest>, I>>(
    object: I,
  ): AddSessionSongResourceRequest {
    const message = createBaseAddSessionSongResourceRequest();
    message.sessionId = object.sessionId ?? 0;
    message.songId = object.songId ?? 0;
    message.resource = (object.resource !== undefined && object.resource !== null)
      ? Resource.fromPartial(object.resource)
      : undefined;
    return message;
  },
};

function createBaseAddSessionSongResourceResponse(): AddSessionSongResourceResponse {
  return { resource: undefined };
}

export const AddSessionSongResourceResponse = {
  encode(message: AddSessionSongResourceResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.resource !== undefined) {
      Resource.encode(message.resource, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AddSessionSongResourceResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddSessionSongResourceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.resource = Resource.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddSessionSongResourceResponse {
    return { resource: isSet(object.resource) ? Resource.fromJSON(object.resource) : undefined };
  },

  toJSON(message: AddSessionSongResourceResponse): unknown {
    const obj: any = {};
    if (message.resource !== undefined) {
      obj.resource = Resource.toJSON(message.resource);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddSessionSongResourceResponse>, I>>(base?: I): AddSessionSongResourceResponse {
    return AddSessionSongResourceResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddSessionSongResourceResponse>, I>>(
    object: I,
  ): AddSessionSongResourceResponse {
    const message = createBaseAddSessionSongResourceResponse();
    message.resource = (object.resource !== undefined && object.resource !== null)
      ? Resource.fromPartial(object.resource)
      : undefined;
    return message;
  },
};

function createBaseListSessionSongResourcesRequest(): ListSessionSongResourcesRequest {
  return { sessionId: 0, songId: 0 };
}

export const ListSessionSongResourcesRequest = {
  encode(message: ListSessionSongResourcesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== 0) {
      writer.uint32(8).int32(message.sessionId);
    }
    if (message.songId !== 0) {
      writer.uint32(16).int32(message.songId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListSessionSongResourcesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSessionSongResourcesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sessionId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.songId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSessionSongResourcesRequest {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.Number(object.sessionId) : 0,
      songId: isSet(object.songId) ? globalThis.Number(object.songId) : 0,
    };
  },

  toJSON(message: ListSessionSongResourcesRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== 0) {
      obj.sessionId = Math.round(message.sessionId);
    }
    if (message.songId !== 0) {
      obj.songId = Math.round(message.songId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListSessionSongResourcesRequest>, I>>(base?: I): ListSessionSongResourcesRequest {
    return ListSessionSongResourcesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListSessionSongResourcesRequest>, I>>(
    object: I,
  ): ListSessionSongResourcesRequest {
    const message = createBaseListSessionSongResourcesRequest();
    message.sessionId = object.sessionId ?? 0;
    message.songId = object.songId ?? 0;
    return message;
  },
};

function createBaseListSessionSongResourcesResponse(): ListSessionSongResourcesResponse {
  return { resources: [], nextPageToken: "", totalSize: 0 };
}

export const ListSessionSongResourcesResponse = {
  encode(message: ListSessionSongResourcesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.resources) {
      Resource.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    if (message.totalSize !== 0) {
      writer.uint32(24).int32(message.totalSize);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListSessionSongResourcesResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSessionSongResourcesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.resources.push(Resource.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.totalSize = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSessionSongResourcesResponse {
    return {
      resources: globalThis.Array.isArray(object?.resources)
        ? object.resources.map((e: any) => Resource.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      totalSize: isSet(object.totalSize) ? globalThis.Number(object.totalSize) : 0,
    };
  },

  toJSON(message: ListSessionSongResourcesResponse): unknown {
    const obj: any = {};
    if (message.resources?.length) {
      obj.resources = message.resources.map((e) => Resource.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.totalSize !== 0) {
      obj.totalSize = Math.round(message.totalSize);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListSessionSongResourcesResponse>, I>>(
    base?: I,
  ): ListSessionSongResourcesResponse {
    return ListSessionSongResourcesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListSessionSongResourcesResponse>, I>>(
    object: I,
  ): ListSessionSongResourcesResponse {
    const message = createBaseListSessionSongResourcesResponse();
    message.resources = object.resources?.map((e) => Resource.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.totalSize = object.totalSize ?? 0;
    return message;
  },
};

function createBaseDeleteSessionSongResourceRequest(): DeleteSessionSongResourceRequest {
  return { sessionId: 0, songId: 0, resourceId: 0 };
}

export const DeleteSessionSongResourceRequest = {
  encode(message: DeleteSessionSongResourceRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== 0) {
      writer.uint32(8).int32(message.sessionId);
    }
    if (message.songId !== 0) {
      writer.uint32(16).int32(message.songId);
    }
    if (message.resourceId !== 0) {
      writer.uint32(24).int32(message.resourceId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteSessionSongResourceRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteSessionSongResourceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sessionId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.songId = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.resourceId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteSessionSongResourceRequest {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.Number(object.sessionId) : 0,
      songId: isSet(object.songId) ? globalThis.Number(object.songId) : 0,
      resourceId: isSet(object.resourceId) ? globalThis.Number(object.resourceId) : 0,
    };
  },

  toJSON(message: DeleteSessionSongResourceRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== 0) {
      obj.sessionId = Math.round(message.sessionId);
    }
    if (message.songId !== 0) {
      obj.songId = Math.round(message.songId);
    }
    if (message.resourceId !== 0) {
      obj.resourceId = Math.round(message.resourceId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteSessionSongResourceRequest>, I>>(
    base?: I,
  ): DeleteSessionSongResourceRequest {
    return DeleteSessionSongResourceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteSessionSongResourceRequest>, I>>(
    object: I,
  ): DeleteSessionSongResourceRequest {
    const message = createBaseDeleteSessionSongResourceRequest();
    message.sessionId = object.sessionId ?? 0;
    message.songId = object.songId ?? 0;
    message.resourceId = object.resourceId ?? 0;
    return message;
  },
};

function createBaseDeleteSessionSongResourceResponse(): DeleteSessionSongResourceResponse {
  return { success: false };
}

export const DeleteSessionSongResourceResponse = {
  encode(message: DeleteSessionSongResourceResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteSessionSongResourceResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteSessionSongResourceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteSessionSongResourceResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: DeleteSessionSongResourceResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteSessionSongResourceResponse>, I>>(
    base?: I,
  ): DeleteSessionSongResourceResponse {
    return DeleteSessionSongResourceResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteSessionSongResourceResponse>, I>>(
    object: I,
  ): DeleteSessionSongResourceResponse {
    const message = createBaseDeleteSessionSongResourceResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseListSessionOrganizersRequest(): ListSessionOrganizersRequest {
  return { sessionId: 0 };
}

export const ListSessionOrganizersRequest = {
  encode(message: ListSessionOrganizersRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== 0) {
      writer.uint32(8).int32(message.sessionId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListSessionOrganizersRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSessionOrganizersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sessionId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSessionOrganizersRequest {
    return { sessionId: isSet(object.sessionId) ? globalThis.Number(object.sessionId) : 0 };
  },

  toJSON(message: ListSessionOrganizersRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== 0) {
      obj.sessionId = Math.round(message.sessionId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListSessionOrganizersRequest>, I>>(base?: I): ListSessionOrganizersRequest {
    return ListSessionOrganizersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListSessionOrganizersRequest>, I>>(object: I): ListSessionOrganizersRequest {
    const message = createBaseListSessionOrganizersRequest();
    message.sessionId = object.sessionId ?? 0;
    return message;
  },
};

function createBaseListSessionOrganizersResponse(): ListSessionOrganizersResponse {
  return { organizers: [] };
}

export const ListSessionOrganizersResponse = {
  encode(message: ListSessionOrganizersResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.organizers) {
      SessionParticipant.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListSessionOrganizersResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSessionOrganizersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.organizers.push(SessionParticipant.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSessionOrganizersResponse {
    return {
      organizers: globalThis.Array.isArray(object?.organizers)
        ? object.organizers.map((e: any) => SessionParticipant.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListSessionOrganizersResponse): unknown {
    const obj: any = {};
    if (message.organizers?.length) {
      obj.organizers = message.organizers.map((e) => SessionParticipant.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListSessionOrganizersResponse>, I>>(base?: I): ListSessionOrganizersResponse {
    return ListSessionOrganizersResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListSessionOrganizersResponse>, I>>(
    object: I,
  ): ListSessionOrganizersResponse {
    const message = createBaseListSessionOrganizersResponse();
    message.organizers = object.organizers?.map((e) => SessionParticipant.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAddSessionOrganizerRequest(): AddSessionOrganizerRequest {
  return { sessionId: 0, userId: 0 };
}

export const AddSessionOrganizerRequest = {
  encode(message: AddSessionOrganizerRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== 0) {
      writer.uint32(8).int32(message.sessionId);
    }
    if (message.userId !== 0) {
      writer.uint32(16).int32(message.userId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AddSessionOrganizerRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddSessionOrganizerRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sessionId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.userId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddSessionOrganizerRequest {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.Number(object.sessionId) : 0,
      userId: isSet(object.userId) ? globalThis.Number(object.userId) : 0,
    };
  },

  toJSON(message: AddSessionOrganizerRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== 0) {
      obj.sessionId = Math.round(message.sessionId);
    }
    if (message.userId !== 0) {
      obj.userId = Math.round(message.userId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddSessionOrganizerRequest>, I>>(base?: I): AddSessionOrganizerRequest {
    return AddSessionOrganizerRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddSessionOrganizerRequest>, I>>(object: I): AddSessionOrganizerRequest {
    const message = createBaseAddSessionOrganizerRequest();
    message.sessionId = object.sessionId ?? 0;
    message.userId = object.userId ?? 0;
    return message;
  },
};

function createBaseAddSessionOrganizerResponse(): AddSessionOrganizerResponse {
  return { organizer: undefined };
}

export const AddSessionOrganizerResponse = {
  encode(message: AddSessionOrganizerResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.organizer !== undefined) {
      SessionParticipant.encode(message.organizer, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AddSessionOrganizerResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddSessionOrganizerResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.organizer = SessionParticipant.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddSessionOrganizerResponse {
    return { organizer: isSet(object.organizer) ? SessionParticipant.fromJSON(object.organizer) : undefined };
  },

  toJSON(message: AddSessionOrganizerResponse): unknown {
    const obj: any = {};
    if (message.organizer !== undefined) {
      obj.organizer = SessionParticipant.toJSON(message.organizer);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddSessionOrganizerResponse>, I>>(base?: I): AddSessionOrganizerResponse {
    return AddSessionOrganizerResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddSessionOrganizerResponse>, I>>(object: I): AddSessionOrganizerResponse {
    const message = createBaseAddSessionOrganizerResponse();
    message.organizer = (object.organizer !== undefined && object.organizer !== null)
      ? SessionParticipant.fromPartial(object.organizer)
      : undefined;
    return message;
  },
};

function createBaseDeleteSessionOrganizerRequest(): DeleteSessionOrganizerRequest {
  return { sessionId: 0, userId: 0 };
}

export const DeleteSessionOrganizerRequest = {
  encode(message: DeleteSessionOrganizerRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== 0) {
      writer.uint32(8).int32(message.sessionId);
    }
    if (message.userId !== 0) {
      writer.uint32(16).int32(message.userId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteSessionOrganizerRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteSessionOrganizerRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sessionId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.userId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteSessionOrganizerRequest {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.Number(object.sessionId) : 0,
      userId: isSet(object.userId) ? globalThis.Number(object.userId) : 0,
    };
  },

  toJSON(message: DeleteSessionOrganizerRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== 0) {
      obj.sessionId = Math.round(message.sessionId);
    }
    if (message.userId !== 0) {
      obj.userId = Math.round(message.userId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteSessionOrganizerRequest>, I>>(base?: I): DeleteSessionOrganizerRequest {
    return DeleteSessionOrganizerRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteSessionOrganizerRequest>, I>>(
    object: I,
  ): DeleteSessionOrganizerRequest {
    const message = createBaseDeleteSessionOrganizerRequest();
    message.sessionId = object.sessionId ?? 0;
    message.userId = object.userId ?? 0;
    return message;
  },
};

function createBaseDeleteSessionOrganizerResponse(): DeleteSessionOrganizerResponse {
  return { success: false };
}

export const DeleteSessionOrganizerResponse = {
  encode(message: DeleteSessionOrganizerResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteSessionOrganizerResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteSessionOrganizerResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteSessionOrganizerResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: DeleteSessionOrganizerResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteSessionOrganizerResponse>, I>>(base?: I): DeleteSessionOrganizerResponse {
    return DeleteSessionOrganizerResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteSessionOrganizerResponse>, I>>(
    object: I,
  ): DeleteSessionOrganizerResponse {
    const message = createBaseDeleteSessionOrganizerResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseCreateSessionThreadRequest(): CreateSessionThreadRequest {
  return { sessionId: 0, thread: undefined };
}

export const CreateSessionThreadRequest = {
  encode(message: CreateSessionThreadRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== 0) {
      writer.uint32(8).int32(message.sessionId);
    }
    if (message.thread !== undefined) {
      Thread.encode(message.thread, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateSessionThreadRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSessionThreadRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sessionId = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.thread = Thread.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSessionThreadRequest {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.Number(object.sessionId) : 0,
      thread: isSet(object.thread) ? Thread.fromJSON(object.thread) : undefined,
    };
  },

  toJSON(message: CreateSessionThreadRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== 0) {
      obj.sessionId = Math.round(message.sessionId);
    }
    if (message.thread !== undefined) {
      obj.thread = Thread.toJSON(message.thread);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateSessionThreadRequest>, I>>(base?: I): CreateSessionThreadRequest {
    return CreateSessionThreadRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateSessionThreadRequest>, I>>(object: I): CreateSessionThreadRequest {
    const message = createBaseCreateSessionThreadRequest();
    message.sessionId = object.sessionId ?? 0;
    message.thread = (object.thread !== undefined && object.thread !== null)
      ? Thread.fromPartial(object.thread)
      : undefined;
    return message;
  },
};

function createBaseCreateSessionThreadResponse(): CreateSessionThreadResponse {
  return { thread: undefined };
}

export const CreateSessionThreadResponse = {
  encode(message: CreateSessionThreadResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.thread !== undefined) {
      Thread.encode(message.thread, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateSessionThreadResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSessionThreadResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.thread = Thread.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSessionThreadResponse {
    return { thread: isSet(object.thread) ? Thread.fromJSON(object.thread) : undefined };
  },

  toJSON(message: CreateSessionThreadResponse): unknown {
    const obj: any = {};
    if (message.thread !== undefined) {
      obj.thread = Thread.toJSON(message.thread);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateSessionThreadResponse>, I>>(base?: I): CreateSessionThreadResponse {
    return CreateSessionThreadResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateSessionThreadResponse>, I>>(object: I): CreateSessionThreadResponse {
    const message = createBaseCreateSessionThreadResponse();
    message.thread = (object.thread !== undefined && object.thread !== null)
      ? Thread.fromPartial(object.thread)
      : undefined;
    return message;
  },
};

function createBaseListSessionThreadsRequest(): ListSessionThreadsRequest {
  return { sessionId: 0 };
}

export const ListSessionThreadsRequest = {
  encode(message: ListSessionThreadsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== 0) {
      writer.uint32(8).int32(message.sessionId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListSessionThreadsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSessionThreadsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sessionId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSessionThreadsRequest {
    return { sessionId: isSet(object.sessionId) ? globalThis.Number(object.sessionId) : 0 };
  },

  toJSON(message: ListSessionThreadsRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== 0) {
      obj.sessionId = Math.round(message.sessionId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListSessionThreadsRequest>, I>>(base?: I): ListSessionThreadsRequest {
    return ListSessionThreadsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListSessionThreadsRequest>, I>>(object: I): ListSessionThreadsRequest {
    const message = createBaseListSessionThreadsRequest();
    message.sessionId = object.sessionId ?? 0;
    return message;
  },
};

function createBaseListSessionThreadsResponse(): ListSessionThreadsResponse {
  return { threads: [] };
}

export const ListSessionThreadsResponse = {
  encode(message: ListSessionThreadsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.threads) {
      Thread.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListSessionThreadsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSessionThreadsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.threads.push(Thread.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSessionThreadsResponse {
    return {
      threads: globalThis.Array.isArray(object?.threads) ? object.threads.map((e: any) => Thread.fromJSON(e)) : [],
    };
  },

  toJSON(message: ListSessionThreadsResponse): unknown {
    const obj: any = {};
    if (message.threads?.length) {
      obj.threads = message.threads.map((e) => Thread.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListSessionThreadsResponse>, I>>(base?: I): ListSessionThreadsResponse {
    return ListSessionThreadsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListSessionThreadsResponse>, I>>(object: I): ListSessionThreadsResponse {
    const message = createBaseListSessionThreadsResponse();
    message.threads = object.threads?.map((e) => Thread.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCreateSongThreadRequest(): CreateSongThreadRequest {
  return { sessionId: 0, songId: 0, thread: undefined };
}

export const CreateSongThreadRequest = {
  encode(message: CreateSongThreadRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== 0) {
      writer.uint32(8).int32(message.sessionId);
    }
    if (message.songId !== 0) {
      writer.uint32(16).int32(message.songId);
    }
    if (message.thread !== undefined) {
      Thread.encode(message.thread, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateSongThreadRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSongThreadRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sessionId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.songId = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.thread = Thread.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSongThreadRequest {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.Number(object.sessionId) : 0,
      songId: isSet(object.songId) ? globalThis.Number(object.songId) : 0,
      thread: isSet(object.thread) ? Thread.fromJSON(object.thread) : undefined,
    };
  },

  toJSON(message: CreateSongThreadRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== 0) {
      obj.sessionId = Math.round(message.sessionId);
    }
    if (message.songId !== 0) {
      obj.songId = Math.round(message.songId);
    }
    if (message.thread !== undefined) {
      obj.thread = Thread.toJSON(message.thread);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateSongThreadRequest>, I>>(base?: I): CreateSongThreadRequest {
    return CreateSongThreadRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateSongThreadRequest>, I>>(object: I): CreateSongThreadRequest {
    const message = createBaseCreateSongThreadRequest();
    message.sessionId = object.sessionId ?? 0;
    message.songId = object.songId ?? 0;
    message.thread = (object.thread !== undefined && object.thread !== null)
      ? Thread.fromPartial(object.thread)
      : undefined;
    return message;
  },
};

function createBaseCreateSongThreadResponse(): CreateSongThreadResponse {
  return { thread: undefined };
}

export const CreateSongThreadResponse = {
  encode(message: CreateSongThreadResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.thread !== undefined) {
      Thread.encode(message.thread, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateSongThreadResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSongThreadResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.thread = Thread.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSongThreadResponse {
    return { thread: isSet(object.thread) ? Thread.fromJSON(object.thread) : undefined };
  },

  toJSON(message: CreateSongThreadResponse): unknown {
    const obj: any = {};
    if (message.thread !== undefined) {
      obj.thread = Thread.toJSON(message.thread);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateSongThreadResponse>, I>>(base?: I): CreateSongThreadResponse {
    return CreateSongThreadResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateSongThreadResponse>, I>>(object: I): CreateSongThreadResponse {
    const message = createBaseCreateSongThreadResponse();
    message.thread = (object.thread !== undefined && object.thread !== null)
      ? Thread.fromPartial(object.thread)
      : undefined;
    return message;
  },
};

function createBaseGetSessionThreadRequest(): GetSessionThreadRequest {
  return { sessionId: 0, threadId: 0 };
}

export const GetSessionThreadRequest = {
  encode(message: GetSessionThreadRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== 0) {
      writer.uint32(8).int32(message.sessionId);
    }
    if (message.threadId !== 0) {
      writer.uint32(16).int32(message.threadId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetSessionThreadRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSessionThreadRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sessionId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.threadId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSessionThreadRequest {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.Number(object.sessionId) : 0,
      threadId: isSet(object.threadId) ? globalThis.Number(object.threadId) : 0,
    };
  },

  toJSON(message: GetSessionThreadRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== 0) {
      obj.sessionId = Math.round(message.sessionId);
    }
    if (message.threadId !== 0) {
      obj.threadId = Math.round(message.threadId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSessionThreadRequest>, I>>(base?: I): GetSessionThreadRequest {
    return GetSessionThreadRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSessionThreadRequest>, I>>(object: I): GetSessionThreadRequest {
    const message = createBaseGetSessionThreadRequest();
    message.sessionId = object.sessionId ?? 0;
    message.threadId = object.threadId ?? 0;
    return message;
  },
};

function createBaseGetSessionThreadResponse(): GetSessionThreadResponse {
  return { thread: undefined };
}

export const GetSessionThreadResponse = {
  encode(message: GetSessionThreadResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.thread !== undefined) {
      Thread.encode(message.thread, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetSessionThreadResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSessionThreadResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.thread = Thread.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSessionThreadResponse {
    return { thread: isSet(object.thread) ? Thread.fromJSON(object.thread) : undefined };
  },

  toJSON(message: GetSessionThreadResponse): unknown {
    const obj: any = {};
    if (message.thread !== undefined) {
      obj.thread = Thread.toJSON(message.thread);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSessionThreadResponse>, I>>(base?: I): GetSessionThreadResponse {
    return GetSessionThreadResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSessionThreadResponse>, I>>(object: I): GetSessionThreadResponse {
    const message = createBaseGetSessionThreadResponse();
    message.thread = (object.thread !== undefined && object.thread !== null)
      ? Thread.fromPartial(object.thread)
      : undefined;
    return message;
  },
};

function createBaseDeleteSessionThreadRequest(): DeleteSessionThreadRequest {
  return { sessionId: 0, threadId: 0 };
}

export const DeleteSessionThreadRequest = {
  encode(message: DeleteSessionThreadRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== 0) {
      writer.uint32(8).int32(message.sessionId);
    }
    if (message.threadId !== 0) {
      writer.uint32(16).int32(message.threadId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteSessionThreadRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteSessionThreadRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sessionId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.threadId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteSessionThreadRequest {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.Number(object.sessionId) : 0,
      threadId: isSet(object.threadId) ? globalThis.Number(object.threadId) : 0,
    };
  },

  toJSON(message: DeleteSessionThreadRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== 0) {
      obj.sessionId = Math.round(message.sessionId);
    }
    if (message.threadId !== 0) {
      obj.threadId = Math.round(message.threadId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteSessionThreadRequest>, I>>(base?: I): DeleteSessionThreadRequest {
    return DeleteSessionThreadRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteSessionThreadRequest>, I>>(object: I): DeleteSessionThreadRequest {
    const message = createBaseDeleteSessionThreadRequest();
    message.sessionId = object.sessionId ?? 0;
    message.threadId = object.threadId ?? 0;
    return message;
  },
};

function createBaseDeleteSessionThreadResponse(): DeleteSessionThreadResponse {
  return { success: false };
}

export const DeleteSessionThreadResponse = {
  encode(message: DeleteSessionThreadResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteSessionThreadResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteSessionThreadResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteSessionThreadResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: DeleteSessionThreadResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteSessionThreadResponse>, I>>(base?: I): DeleteSessionThreadResponse {
    return DeleteSessionThreadResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteSessionThreadResponse>, I>>(object: I): DeleteSessionThreadResponse {
    const message = createBaseDeleteSessionThreadResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseCreateSessionNotificationRequest(): CreateSessionNotificationRequest {
  return { sessionId: 0, content: "", userIds: [] };
}

export const CreateSessionNotificationRequest = {
  encode(message: CreateSessionNotificationRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== 0) {
      writer.uint32(8).int32(message.sessionId);
    }
    if (message.content !== "") {
      writer.uint32(18).string(message.content);
    }
    writer.uint32(26).fork();
    for (const v of message.userIds) {
      writer.int32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateSessionNotificationRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSessionNotificationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sessionId = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.content = reader.string();
          continue;
        case 3:
          if (tag === 24) {
            message.userIds.push(reader.int32());

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.userIds.push(reader.int32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSessionNotificationRequest {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.Number(object.sessionId) : 0,
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      userIds: globalThis.Array.isArray(object?.userIds) ? object.userIds.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: CreateSessionNotificationRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== 0) {
      obj.sessionId = Math.round(message.sessionId);
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.userIds?.length) {
      obj.userIds = message.userIds.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateSessionNotificationRequest>, I>>(
    base?: I,
  ): CreateSessionNotificationRequest {
    return CreateSessionNotificationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateSessionNotificationRequest>, I>>(
    object: I,
  ): CreateSessionNotificationRequest {
    const message = createBaseCreateSessionNotificationRequest();
    message.sessionId = object.sessionId ?? 0;
    message.content = object.content ?? "";
    message.userIds = object.userIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseCreateSessionNotificationResponse(): CreateSessionNotificationResponse {
  return { success: false };
}

export const CreateSessionNotificationResponse = {
  encode(message: CreateSessionNotificationResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateSessionNotificationResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSessionNotificationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSessionNotificationResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: CreateSessionNotificationResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateSessionNotificationResponse>, I>>(
    base?: I,
  ): CreateSessionNotificationResponse {
    return CreateSessionNotificationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateSessionNotificationResponse>, I>>(
    object: I,
  ): CreateSessionNotificationResponse {
    const message = createBaseCreateSessionNotificationResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseGetSessionTimetableRequest(): GetSessionTimetableRequest {
  return { sessionId: 0 };
}

export const GetSessionTimetableRequest = {
  encode(message: GetSessionTimetableRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== 0) {
      writer.uint32(8).int32(message.sessionId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetSessionTimetableRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSessionTimetableRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sessionId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSessionTimetableRequest {
    return { sessionId: isSet(object.sessionId) ? globalThis.Number(object.sessionId) : 0 };
  },

  toJSON(message: GetSessionTimetableRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== 0) {
      obj.sessionId = Math.round(message.sessionId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSessionTimetableRequest>, I>>(base?: I): GetSessionTimetableRequest {
    return GetSessionTimetableRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSessionTimetableRequest>, I>>(object: I): GetSessionTimetableRequest {
    const message = createBaseGetSessionTimetableRequest();
    message.sessionId = object.sessionId ?? 0;
    return message;
  },
};

function createBaseGetSessionTimetableResponse(): GetSessionTimetableResponse {
  return { timetable: undefined };
}

export const GetSessionTimetableResponse = {
  encode(message: GetSessionTimetableResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.timetable !== undefined) {
      Timetable.encode(message.timetable, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetSessionTimetableResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSessionTimetableResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.timetable = Timetable.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSessionTimetableResponse {
    return { timetable: isSet(object.timetable) ? Timetable.fromJSON(object.timetable) : undefined };
  },

  toJSON(message: GetSessionTimetableResponse): unknown {
    const obj: any = {};
    if (message.timetable !== undefined) {
      obj.timetable = Timetable.toJSON(message.timetable);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSessionTimetableResponse>, I>>(base?: I): GetSessionTimetableResponse {
    return GetSessionTimetableResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSessionTimetableResponse>, I>>(object: I): GetSessionTimetableResponse {
    const message = createBaseGetSessionTimetableResponse();
    message.timetable = (object.timetable !== undefined && object.timetable !== null)
      ? Timetable.fromPartial(object.timetable)
      : undefined;
    return message;
  },
};

function createBaseUpdateSessionTimetableRequest(): UpdateSessionTimetableRequest {
  return { sessionId: 0, timetable: undefined };
}

export const UpdateSessionTimetableRequest = {
  encode(message: UpdateSessionTimetableRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== 0) {
      writer.uint32(8).int32(message.sessionId);
    }
    if (message.timetable !== undefined) {
      Timetable.encode(message.timetable, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateSessionTimetableRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSessionTimetableRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sessionId = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.timetable = Timetable.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateSessionTimetableRequest {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.Number(object.sessionId) : 0,
      timetable: isSet(object.timetable) ? Timetable.fromJSON(object.timetable) : undefined,
    };
  },

  toJSON(message: UpdateSessionTimetableRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== 0) {
      obj.sessionId = Math.round(message.sessionId);
    }
    if (message.timetable !== undefined) {
      obj.timetable = Timetable.toJSON(message.timetable);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateSessionTimetableRequest>, I>>(base?: I): UpdateSessionTimetableRequest {
    return UpdateSessionTimetableRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateSessionTimetableRequest>, I>>(
    object: I,
  ): UpdateSessionTimetableRequest {
    const message = createBaseUpdateSessionTimetableRequest();
    message.sessionId = object.sessionId ?? 0;
    message.timetable = (object.timetable !== undefined && object.timetable !== null)
      ? Timetable.fromPartial(object.timetable)
      : undefined;
    return message;
  },
};

function createBaseUpdateSessionTimetableResponse(): UpdateSessionTimetableResponse {
  return { timetable: undefined };
}

export const UpdateSessionTimetableResponse = {
  encode(message: UpdateSessionTimetableResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.timetable !== undefined) {
      Timetable.encode(message.timetable, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateSessionTimetableResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSessionTimetableResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.timetable = Timetable.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateSessionTimetableResponse {
    return { timetable: isSet(object.timetable) ? Timetable.fromJSON(object.timetable) : undefined };
  },

  toJSON(message: UpdateSessionTimetableResponse): unknown {
    const obj: any = {};
    if (message.timetable !== undefined) {
      obj.timetable = Timetable.toJSON(message.timetable);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateSessionTimetableResponse>, I>>(base?: I): UpdateSessionTimetableResponse {
    return UpdateSessionTimetableResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateSessionTimetableResponse>, I>>(
    object: I,
  ): UpdateSessionTimetableResponse {
    const message = createBaseUpdateSessionTimetableResponse();
    message.timetable = (object.timetable !== undefined && object.timetable !== null)
      ? Timetable.fromPartial(object.timetable)
      : undefined;
    return message;
  },
};

function createBaseGetOptimizedTimetableRequest(): GetOptimizedTimetableRequest {
  return { sessionId: 0, optimizationRules: [] };
}

export const GetOptimizedTimetableRequest = {
  encode(message: GetOptimizedTimetableRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== 0) {
      writer.uint32(8).int32(message.sessionId);
    }
    for (const v of message.optimizationRules) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetOptimizedTimetableRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOptimizedTimetableRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sessionId = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.optimizationRules.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetOptimizedTimetableRequest {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.Number(object.sessionId) : 0,
      optimizationRules: globalThis.Array.isArray(object?.optimizationRules)
        ? object.optimizationRules.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: GetOptimizedTimetableRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== 0) {
      obj.sessionId = Math.round(message.sessionId);
    }
    if (message.optimizationRules?.length) {
      obj.optimizationRules = message.optimizationRules;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetOptimizedTimetableRequest>, I>>(base?: I): GetOptimizedTimetableRequest {
    return GetOptimizedTimetableRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetOptimizedTimetableRequest>, I>>(object: I): GetOptimizedTimetableRequest {
    const message = createBaseGetOptimizedTimetableRequest();
    message.sessionId = object.sessionId ?? 0;
    message.optimizationRules = object.optimizationRules?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetOptimizedTimetableResponse(): GetOptimizedTimetableResponse {
  return { timetable: undefined };
}

export const GetOptimizedTimetableResponse = {
  encode(message: GetOptimizedTimetableResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.timetable !== undefined) {
      Timetable.encode(message.timetable, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetOptimizedTimetableResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOptimizedTimetableResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.timetable = Timetable.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetOptimizedTimetableResponse {
    return { timetable: isSet(object.timetable) ? Timetable.fromJSON(object.timetable) : undefined };
  },

  toJSON(message: GetOptimizedTimetableResponse): unknown {
    const obj: any = {};
    if (message.timetable !== undefined) {
      obj.timetable = Timetable.toJSON(message.timetable);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetOptimizedTimetableResponse>, I>>(base?: I): GetOptimizedTimetableResponse {
    return GetOptimizedTimetableResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetOptimizedTimetableResponse>, I>>(
    object: I,
  ): GetOptimizedTimetableResponse {
    const message = createBaseGetOptimizedTimetableResponse();
    message.timetable = (object.timetable !== undefined && object.timetable !== null)
      ? Timetable.fromPartial(object.timetable)
      : undefined;
    return message;
  },
};

function createBaseGetTimetableProgressRequest(): GetTimetableProgressRequest {
  return { sessionId: 0 };
}

export const GetTimetableProgressRequest = {
  encode(message: GetTimetableProgressRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== 0) {
      writer.uint32(8).int32(message.sessionId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetTimetableProgressRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTimetableProgressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sessionId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTimetableProgressRequest {
    return { sessionId: isSet(object.sessionId) ? globalThis.Number(object.sessionId) : 0 };
  },

  toJSON(message: GetTimetableProgressRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== 0) {
      obj.sessionId = Math.round(message.sessionId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTimetableProgressRequest>, I>>(base?: I): GetTimetableProgressRequest {
    return GetTimetableProgressRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTimetableProgressRequest>, I>>(object: I): GetTimetableProgressRequest {
    const message = createBaseGetTimetableProgressRequest();
    message.sessionId = object.sessionId ?? 0;
    return message;
  },
};

function createBaseGetTimetableProgressResponse(): GetTimetableProgressResponse {
  return { completedEntries: [], currentEntry: undefined };
}

export const GetTimetableProgressResponse = {
  encode(message: GetTimetableProgressResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.completedEntries) {
      TimetableEntry.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.currentEntry !== undefined) {
      TimetableEntry.encode(message.currentEntry, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetTimetableProgressResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTimetableProgressResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.completedEntries.push(TimetableEntry.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.currentEntry = TimetableEntry.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTimetableProgressResponse {
    return {
      completedEntries: globalThis.Array.isArray(object?.completedEntries)
        ? object.completedEntries.map((e: any) => TimetableEntry.fromJSON(e))
        : [],
      currentEntry: isSet(object.currentEntry) ? TimetableEntry.fromJSON(object.currentEntry) : undefined,
    };
  },

  toJSON(message: GetTimetableProgressResponse): unknown {
    const obj: any = {};
    if (message.completedEntries?.length) {
      obj.completedEntries = message.completedEntries.map((e) => TimetableEntry.toJSON(e));
    }
    if (message.currentEntry !== undefined) {
      obj.currentEntry = TimetableEntry.toJSON(message.currentEntry);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTimetableProgressResponse>, I>>(base?: I): GetTimetableProgressResponse {
    return GetTimetableProgressResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTimetableProgressResponse>, I>>(object: I): GetTimetableProgressResponse {
    const message = createBaseGetTimetableProgressResponse();
    message.completedEntries = object.completedEntries?.map((e) => TimetableEntry.fromPartial(e)) || [];
    message.currentEntry = (object.currentEntry !== undefined && object.currentEntry !== null)
      ? TimetableEntry.fromPartial(object.currentEntry)
      : undefined;
    return message;
  },
};

function createBaseUpdateTimetableProgressRequest(): UpdateTimetableProgressRequest {
  return { sessionId: 0, currentEntryId: 0 };
}

export const UpdateTimetableProgressRequest = {
  encode(message: UpdateTimetableProgressRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== 0) {
      writer.uint32(8).int32(message.sessionId);
    }
    if (message.currentEntryId !== 0) {
      writer.uint32(16).int32(message.currentEntryId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateTimetableProgressRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateTimetableProgressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sessionId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.currentEntryId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateTimetableProgressRequest {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.Number(object.sessionId) : 0,
      currentEntryId: isSet(object.currentEntryId) ? globalThis.Number(object.currentEntryId) : 0,
    };
  },

  toJSON(message: UpdateTimetableProgressRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== 0) {
      obj.sessionId = Math.round(message.sessionId);
    }
    if (message.currentEntryId !== 0) {
      obj.currentEntryId = Math.round(message.currentEntryId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateTimetableProgressRequest>, I>>(base?: I): UpdateTimetableProgressRequest {
    return UpdateTimetableProgressRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateTimetableProgressRequest>, I>>(
    object: I,
  ): UpdateTimetableProgressRequest {
    const message = createBaseUpdateTimetableProgressRequest();
    message.sessionId = object.sessionId ?? 0;
    message.currentEntryId = object.currentEntryId ?? 0;
    return message;
  },
};

function createBaseUpdateTimetableProgressResponse(): UpdateTimetableProgressResponse {
  return { success: false };
}

export const UpdateTimetableProgressResponse = {
  encode(message: UpdateTimetableProgressResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateTimetableProgressResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateTimetableProgressResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateTimetableProgressResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: UpdateTimetableProgressResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateTimetableProgressResponse>, I>>(base?: I): UpdateTimetableProgressResponse {
    return UpdateTimetableProgressResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateTimetableProgressResponse>, I>>(
    object: I,
  ): UpdateTimetableProgressResponse {
    const message = createBaseUpdateTimetableProgressResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseAddSessionResourceRequest(): AddSessionResourceRequest {
  return { sessionId: 0, resource: undefined };
}

export const AddSessionResourceRequest = {
  encode(message: AddSessionResourceRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== 0) {
      writer.uint32(8).int32(message.sessionId);
    }
    if (message.resource !== undefined) {
      Resource.encode(message.resource, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AddSessionResourceRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddSessionResourceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sessionId = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.resource = Resource.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddSessionResourceRequest {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.Number(object.sessionId) : 0,
      resource: isSet(object.resource) ? Resource.fromJSON(object.resource) : undefined,
    };
  },

  toJSON(message: AddSessionResourceRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== 0) {
      obj.sessionId = Math.round(message.sessionId);
    }
    if (message.resource !== undefined) {
      obj.resource = Resource.toJSON(message.resource);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddSessionResourceRequest>, I>>(base?: I): AddSessionResourceRequest {
    return AddSessionResourceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddSessionResourceRequest>, I>>(object: I): AddSessionResourceRequest {
    const message = createBaseAddSessionResourceRequest();
    message.sessionId = object.sessionId ?? 0;
    message.resource = (object.resource !== undefined && object.resource !== null)
      ? Resource.fromPartial(object.resource)
      : undefined;
    return message;
  },
};

function createBaseAddSessionResourceResponse(): AddSessionResourceResponse {
  return { resource: undefined };
}

export const AddSessionResourceResponse = {
  encode(message: AddSessionResourceResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.resource !== undefined) {
      Resource.encode(message.resource, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AddSessionResourceResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddSessionResourceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.resource = Resource.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddSessionResourceResponse {
    return { resource: isSet(object.resource) ? Resource.fromJSON(object.resource) : undefined };
  },

  toJSON(message: AddSessionResourceResponse): unknown {
    const obj: any = {};
    if (message.resource !== undefined) {
      obj.resource = Resource.toJSON(message.resource);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddSessionResourceResponse>, I>>(base?: I): AddSessionResourceResponse {
    return AddSessionResourceResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddSessionResourceResponse>, I>>(object: I): AddSessionResourceResponse {
    const message = createBaseAddSessionResourceResponse();
    message.resource = (object.resource !== undefined && object.resource !== null)
      ? Resource.fromPartial(object.resource)
      : undefined;
    return message;
  },
};

function createBaseListSessionResourcesRequest(): ListSessionResourcesRequest {
  return { sessionId: 0 };
}

export const ListSessionResourcesRequest = {
  encode(message: ListSessionResourcesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== 0) {
      writer.uint32(8).int32(message.sessionId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListSessionResourcesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSessionResourcesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sessionId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSessionResourcesRequest {
    return { sessionId: isSet(object.sessionId) ? globalThis.Number(object.sessionId) : 0 };
  },

  toJSON(message: ListSessionResourcesRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== 0) {
      obj.sessionId = Math.round(message.sessionId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListSessionResourcesRequest>, I>>(base?: I): ListSessionResourcesRequest {
    return ListSessionResourcesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListSessionResourcesRequest>, I>>(object: I): ListSessionResourcesRequest {
    const message = createBaseListSessionResourcesRequest();
    message.sessionId = object.sessionId ?? 0;
    return message;
  },
};

function createBaseListSessionResourcesResponse(): ListSessionResourcesResponse {
  return { resources: [] };
}

export const ListSessionResourcesResponse = {
  encode(message: ListSessionResourcesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.resources) {
      Resource.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListSessionResourcesResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSessionResourcesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.resources.push(Resource.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSessionResourcesResponse {
    return {
      resources: globalThis.Array.isArray(object?.resources)
        ? object.resources.map((e: any) => Resource.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListSessionResourcesResponse): unknown {
    const obj: any = {};
    if (message.resources?.length) {
      obj.resources = message.resources.map((e) => Resource.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListSessionResourcesResponse>, I>>(base?: I): ListSessionResourcesResponse {
    return ListSessionResourcesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListSessionResourcesResponse>, I>>(object: I): ListSessionResourcesResponse {
    const message = createBaseListSessionResourcesResponse();
    message.resources = object.resources?.map((e) => Resource.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDeleteSessionResourceRequest(): DeleteSessionResourceRequest {
  return { sessionId: 0, resourceId: 0 };
}

export const DeleteSessionResourceRequest = {
  encode(message: DeleteSessionResourceRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== 0) {
      writer.uint32(8).int32(message.sessionId);
    }
    if (message.resourceId !== 0) {
      writer.uint32(16).int32(message.resourceId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteSessionResourceRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteSessionResourceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sessionId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.resourceId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteSessionResourceRequest {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.Number(object.sessionId) : 0,
      resourceId: isSet(object.resourceId) ? globalThis.Number(object.resourceId) : 0,
    };
  },

  toJSON(message: DeleteSessionResourceRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== 0) {
      obj.sessionId = Math.round(message.sessionId);
    }
    if (message.resourceId !== 0) {
      obj.resourceId = Math.round(message.resourceId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteSessionResourceRequest>, I>>(base?: I): DeleteSessionResourceRequest {
    return DeleteSessionResourceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteSessionResourceRequest>, I>>(object: I): DeleteSessionResourceRequest {
    const message = createBaseDeleteSessionResourceRequest();
    message.sessionId = object.sessionId ?? 0;
    message.resourceId = object.resourceId ?? 0;
    return message;
  },
};

function createBaseDeleteSessionResourceResponse(): DeleteSessionResourceResponse {
  return { success: false };
}

export const DeleteSessionResourceResponse = {
  encode(message: DeleteSessionResourceResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteSessionResourceResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteSessionResourceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteSessionResourceResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: DeleteSessionResourceResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteSessionResourceResponse>, I>>(base?: I): DeleteSessionResourceResponse {
    return DeleteSessionResourceResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteSessionResourceResponse>, I>>(
    object: I,
  ): DeleteSessionResourceResponse {
    const message = createBaseDeleteSessionResourceResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseAddSessionFeedbackRequest(): AddSessionFeedbackRequest {
  return { feedback: undefined };
}

export const AddSessionFeedbackRequest = {
  encode(message: AddSessionFeedbackRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.feedback !== undefined) {
      SessionFeedback.encode(message.feedback, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AddSessionFeedbackRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddSessionFeedbackRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.feedback = SessionFeedback.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddSessionFeedbackRequest {
    return { feedback: isSet(object.feedback) ? SessionFeedback.fromJSON(object.feedback) : undefined };
  },

  toJSON(message: AddSessionFeedbackRequest): unknown {
    const obj: any = {};
    if (message.feedback !== undefined) {
      obj.feedback = SessionFeedback.toJSON(message.feedback);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddSessionFeedbackRequest>, I>>(base?: I): AddSessionFeedbackRequest {
    return AddSessionFeedbackRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddSessionFeedbackRequest>, I>>(object: I): AddSessionFeedbackRequest {
    const message = createBaseAddSessionFeedbackRequest();
    message.feedback = (object.feedback !== undefined && object.feedback !== null)
      ? SessionFeedback.fromPartial(object.feedback)
      : undefined;
    return message;
  },
};

function createBaseAddSessionFeedbackResponse(): AddSessionFeedbackResponse {
  return { success: false };
}

export const AddSessionFeedbackResponse = {
  encode(message: AddSessionFeedbackResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AddSessionFeedbackResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddSessionFeedbackResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddSessionFeedbackResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: AddSessionFeedbackResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddSessionFeedbackResponse>, I>>(base?: I): AddSessionFeedbackResponse {
    return AddSessionFeedbackResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddSessionFeedbackResponse>, I>>(object: I): AddSessionFeedbackResponse {
    const message = createBaseAddSessionFeedbackResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseListSessionFeedbacksRequest(): ListSessionFeedbacksRequest {
  return { sessionId: 0 };
}

export const ListSessionFeedbacksRequest = {
  encode(message: ListSessionFeedbacksRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== 0) {
      writer.uint32(8).int32(message.sessionId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListSessionFeedbacksRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSessionFeedbacksRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sessionId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSessionFeedbacksRequest {
    return { sessionId: isSet(object.sessionId) ? globalThis.Number(object.sessionId) : 0 };
  },

  toJSON(message: ListSessionFeedbacksRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== 0) {
      obj.sessionId = Math.round(message.sessionId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListSessionFeedbacksRequest>, I>>(base?: I): ListSessionFeedbacksRequest {
    return ListSessionFeedbacksRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListSessionFeedbacksRequest>, I>>(object: I): ListSessionFeedbacksRequest {
    const message = createBaseListSessionFeedbacksRequest();
    message.sessionId = object.sessionId ?? 0;
    return message;
  },
};

function createBaseListSessionFeedbacksResponse(): ListSessionFeedbacksResponse {
  return { feedbacks: [] };
}

export const ListSessionFeedbacksResponse = {
  encode(message: ListSessionFeedbacksResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.feedbacks) {
      SessionFeedback.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListSessionFeedbacksResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSessionFeedbacksResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.feedbacks.push(SessionFeedback.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSessionFeedbacksResponse {
    return {
      feedbacks: globalThis.Array.isArray(object?.feedbacks)
        ? object.feedbacks.map((e: any) => SessionFeedback.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListSessionFeedbacksResponse): unknown {
    const obj: any = {};
    if (message.feedbacks?.length) {
      obj.feedbacks = message.feedbacks.map((e) => SessionFeedback.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListSessionFeedbacksResponse>, I>>(base?: I): ListSessionFeedbacksResponse {
    return ListSessionFeedbacksResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListSessionFeedbacksResponse>, I>>(object: I): ListSessionFeedbacksResponse {
    const message = createBaseListSessionFeedbacksResponse();
    message.feedbacks = object.feedbacks?.map((e) => SessionFeedback.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListRelatedSessionsRequest(): ListRelatedSessionsRequest {
  return { sessionId: 0 };
}

export const ListRelatedSessionsRequest = {
  encode(message: ListRelatedSessionsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== 0) {
      writer.uint32(8).int32(message.sessionId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListRelatedSessionsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRelatedSessionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sessionId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRelatedSessionsRequest {
    return { sessionId: isSet(object.sessionId) ? globalThis.Number(object.sessionId) : 0 };
  },

  toJSON(message: ListRelatedSessionsRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== 0) {
      obj.sessionId = Math.round(message.sessionId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListRelatedSessionsRequest>, I>>(base?: I): ListRelatedSessionsRequest {
    return ListRelatedSessionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListRelatedSessionsRequest>, I>>(object: I): ListRelatedSessionsRequest {
    const message = createBaseListRelatedSessionsRequest();
    message.sessionId = object.sessionId ?? 0;
    return message;
  },
};

function createBaseListRelatedSessionsResponse(): ListRelatedSessionsResponse {
  return { sessions: [] };
}

export const ListRelatedSessionsResponse = {
  encode(message: ListRelatedSessionsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.sessions) {
      Session.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListRelatedSessionsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRelatedSessionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sessions.push(Session.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRelatedSessionsResponse {
    return {
      sessions: globalThis.Array.isArray(object?.sessions) ? object.sessions.map((e: any) => Session.fromJSON(e)) : [],
    };
  },

  toJSON(message: ListRelatedSessionsResponse): unknown {
    const obj: any = {};
    if (message.sessions?.length) {
      obj.sessions = message.sessions.map((e) => Session.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListRelatedSessionsResponse>, I>>(base?: I): ListRelatedSessionsResponse {
    return ListRelatedSessionsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListRelatedSessionsResponse>, I>>(object: I): ListRelatedSessionsResponse {
    const message = createBaseListRelatedSessionsResponse();
    message.sessions = object.sessions?.map((e) => Session.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAddRelatedSessionRequest(): AddRelatedSessionRequest {
  return { sessionId: 0, relatedSessionId: 0 };
}

export const AddRelatedSessionRequest = {
  encode(message: AddRelatedSessionRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== 0) {
      writer.uint32(8).int32(message.sessionId);
    }
    if (message.relatedSessionId !== 0) {
      writer.uint32(16).int32(message.relatedSessionId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AddRelatedSessionRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddRelatedSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sessionId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.relatedSessionId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddRelatedSessionRequest {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.Number(object.sessionId) : 0,
      relatedSessionId: isSet(object.relatedSessionId) ? globalThis.Number(object.relatedSessionId) : 0,
    };
  },

  toJSON(message: AddRelatedSessionRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== 0) {
      obj.sessionId = Math.round(message.sessionId);
    }
    if (message.relatedSessionId !== 0) {
      obj.relatedSessionId = Math.round(message.relatedSessionId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddRelatedSessionRequest>, I>>(base?: I): AddRelatedSessionRequest {
    return AddRelatedSessionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddRelatedSessionRequest>, I>>(object: I): AddRelatedSessionRequest {
    const message = createBaseAddRelatedSessionRequest();
    message.sessionId = object.sessionId ?? 0;
    message.relatedSessionId = object.relatedSessionId ?? 0;
    return message;
  },
};

function createBaseAddRelatedSessionResponse(): AddRelatedSessionResponse {
  return { success: false };
}

export const AddRelatedSessionResponse = {
  encode(message: AddRelatedSessionResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AddRelatedSessionResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddRelatedSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddRelatedSessionResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: AddRelatedSessionResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddRelatedSessionResponse>, I>>(base?: I): AddRelatedSessionResponse {
    return AddRelatedSessionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddRelatedSessionResponse>, I>>(object: I): AddRelatedSessionResponse {
    const message = createBaseAddRelatedSessionResponse();
    message.success = object.success ?? false;
    return message;
  },
};

export interface SessionService {
  /**
   * Session Management
   * POST /sessions
   */
  CreateSession(request: CreateSessionRequest): Promise<CreateSessionResponse>;
  /** GET /sessions/{id} */
  GetSession(request: GetSessionRequest): Promise<GetSessionResponse>;
  /** PUT /sessions/{id} */
  UpdateSession(request: UpdateSessionRequest): Promise<UpdateSessionResponse>;
  /** PUT /sessions/{id}/status */
  UpdateSessionStatus(request: UpdateSessionStatusRequest): Promise<UpdateSessionStatusResponse>;
  /** PUT /sessions/{id}/cancel */
  CancelSession(request: CancelSessionRequest): Promise<CancelSessionResponse>;
  /** POST /sessions/{id}/duplicate */
  DuplicateSession(request: DuplicateSessionRequest): Promise<DuplicateSessionResponse>;
  /**
   * Schedule & Location
   * PUT /sessions/{id}/schedule
   */
  UpdateSessionSchedule(request: UpdateSessionScheduleRequest): Promise<UpdateSessionScheduleResponse>;
  /** PUT /sessions/{id}/location */
  UpdateSessionLocation(request: UpdateSessionLocationRequest): Promise<UpdateSessionLocationResponse>;
  /**
   * Participants
   * GET /sessions/{id}/participants
   */
  ListSessionParticipants(request: ListSessionParticipantsRequest): Promise<ListSessionParticipantsResponse>;
  /** POST /sessions/{id}/participants */
  AddSessionParticipant(request: AddSessionParticipantRequest): Promise<AddSessionParticipantResponse>;
  /** PUT /sessions/{id}/participants/{participantId} */
  UpdateSessionParticipant(request: UpdateSessionParticipantRequest): Promise<UpdateSessionParticipantResponse>;
  /**
   * Song Entries
   * POST /sessions/{id}/songs/{songId}/entries
   */
  AddSongEntry(request: AddSongEntryRequest): Promise<AddSongEntryResponse>;
  /** DELETE /sessions/{id}/songs/{songId}/entries/{entryId} */
  DeleteSongEntry(request: DeleteSongEntryRequest): Promise<DeleteSongEntryResponse>;
  /**
   * Song Resources
   * POST /sessions/{id}/songs/{songId}/resources
   */
  AddSessionSongResource(request: AddSessionSongResourceRequest): Promise<AddSessionSongResourceResponse>;
  /** GET /sessions/{id}/songs/{songId}/resources */
  ListSessionSongResources(request: ListSessionSongResourcesRequest): Promise<ListSessionSongResourcesResponse>;
  /** DELETE /sessions/{id}/songs/{songId}/resources */
  DeleteSessionSongResource(request: DeleteSessionSongResourceRequest): Promise<DeleteSessionSongResourceResponse>;
  /**
   * Organizers
   * GET /sessions/{id}/organizers
   */
  ListSessionOrganizers(request: ListSessionOrganizersRequest): Promise<ListSessionOrganizersResponse>;
  /** POST /sessions/{id}/organizers */
  AddSessionOrganizer(request: AddSessionOrganizerRequest): Promise<AddSessionOrganizerResponse>;
  /** DELETE /sessions/{id}/organizers/{userId} */
  DeleteSessionOrganizer(request: DeleteSessionOrganizerRequest): Promise<DeleteSessionOrganizerResponse>;
  /**
   * Communication
   * POST /sessions/{id}/threads
   */
  CreateSessionThread(request: CreateSessionThreadRequest): Promise<CreateSessionThreadResponse>;
  /** GET /sessions/{id}/threads */
  ListSessionThreads(request: ListSessionThreadsRequest): Promise<ListSessionThreadsResponse>;
  /** POST /sessions/{id}/songs/{songId}/threads */
  CreateSongThread(request: CreateSongThreadRequest): Promise<CreateSongThreadResponse>;
  /** GET /sessions/{id}/threads/{id} */
  GetSessionThread(request: GetSessionThreadRequest): Promise<GetSessionThreadResponse>;
  /** DELETE /sessions/{id}/threads/{id} */
  DeleteSessionThread(request: DeleteSessionThreadRequest): Promise<DeleteSessionThreadResponse>;
  /** POST /sessions/{id}/notifications */
  CreateSessionNotification(request: CreateSessionNotificationRequest): Promise<CreateSessionNotificationResponse>;
  /**
   * Timetable
   * GET /sessions/{id}/timetable
   */
  GetSessionTimetable(request: GetSessionTimetableRequest): Promise<GetSessionTimetableResponse>;
  /** PUT /sessions/{id}/timetable */
  UpdateSessionTimetable(request: UpdateSessionTimetableRequest): Promise<UpdateSessionTimetableResponse>;
  /** GET /sessions/{id}/timetable/optimized */
  GetOptimizedTimetable(request: GetOptimizedTimetableRequest): Promise<GetOptimizedTimetableResponse>;
  /** GET /sessions/{id}/timetable/progress */
  GetTimetableProgress(request: GetTimetableProgressRequest): Promise<GetTimetableProgressResponse>;
  /** PUT /sessions/{id}/timetable/progress */
  UpdateTimetableProgress(request: UpdateTimetableProgressRequest): Promise<UpdateTimetableProgressResponse>;
  /**
   * Session Resources
   * POST /sessions/{id}/resources
   */
  AddSessionResource(request: AddSessionResourceRequest): Promise<AddSessionResourceResponse>;
  /** GET /sessions/{id}/resources */
  ListSessionResources(request: ListSessionResourcesRequest): Promise<ListSessionResourcesResponse>;
  /** DELETE /sessions/{id}/resources */
  DeleteSessionResource(request: DeleteSessionResourceRequest): Promise<DeleteSessionResourceResponse>;
  /**
   * Feedbacks
   * POST /sessions/{id}/feedbacks
   */
  AddSessionFeedback(request: AddSessionFeedbackRequest): Promise<AddSessionFeedbackResponse>;
  /** GET /sessions/{id}/ratings */
  ListSessionFeedbacks(request: ListSessionFeedbacksRequest): Promise<ListSessionFeedbacksResponse>;
  /**
   * Related Sessions
   * GET /sessions/{id}/related-sessions
   */
  ListRelatedSessions(request: ListRelatedSessionsRequest): Promise<ListRelatedSessionsResponse>;
  /** POST /sessions/{id}/related-sessions */
  AddRelatedSession(request: AddRelatedSessionRequest): Promise<AddRelatedSessionResponse>;
}

export const SessionServiceServiceName = "bst.v1.SessionService";
export class SessionServiceClientImpl implements SessionService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || SessionServiceServiceName;
    this.rpc = rpc;
    this.CreateSession = this.CreateSession.bind(this);
    this.GetSession = this.GetSession.bind(this);
    this.UpdateSession = this.UpdateSession.bind(this);
    this.UpdateSessionStatus = this.UpdateSessionStatus.bind(this);
    this.CancelSession = this.CancelSession.bind(this);
    this.DuplicateSession = this.DuplicateSession.bind(this);
    this.UpdateSessionSchedule = this.UpdateSessionSchedule.bind(this);
    this.UpdateSessionLocation = this.UpdateSessionLocation.bind(this);
    this.ListSessionParticipants = this.ListSessionParticipants.bind(this);
    this.AddSessionParticipant = this.AddSessionParticipant.bind(this);
    this.UpdateSessionParticipant = this.UpdateSessionParticipant.bind(this);
    this.AddSongEntry = this.AddSongEntry.bind(this);
    this.DeleteSongEntry = this.DeleteSongEntry.bind(this);
    this.AddSessionSongResource = this.AddSessionSongResource.bind(this);
    this.ListSessionSongResources = this.ListSessionSongResources.bind(this);
    this.DeleteSessionSongResource = this.DeleteSessionSongResource.bind(this);
    this.ListSessionOrganizers = this.ListSessionOrganizers.bind(this);
    this.AddSessionOrganizer = this.AddSessionOrganizer.bind(this);
    this.DeleteSessionOrganizer = this.DeleteSessionOrganizer.bind(this);
    this.CreateSessionThread = this.CreateSessionThread.bind(this);
    this.ListSessionThreads = this.ListSessionThreads.bind(this);
    this.CreateSongThread = this.CreateSongThread.bind(this);
    this.GetSessionThread = this.GetSessionThread.bind(this);
    this.DeleteSessionThread = this.DeleteSessionThread.bind(this);
    this.CreateSessionNotification = this.CreateSessionNotification.bind(this);
    this.GetSessionTimetable = this.GetSessionTimetable.bind(this);
    this.UpdateSessionTimetable = this.UpdateSessionTimetable.bind(this);
    this.GetOptimizedTimetable = this.GetOptimizedTimetable.bind(this);
    this.GetTimetableProgress = this.GetTimetableProgress.bind(this);
    this.UpdateTimetableProgress = this.UpdateTimetableProgress.bind(this);
    this.AddSessionResource = this.AddSessionResource.bind(this);
    this.ListSessionResources = this.ListSessionResources.bind(this);
    this.DeleteSessionResource = this.DeleteSessionResource.bind(this);
    this.AddSessionFeedback = this.AddSessionFeedback.bind(this);
    this.ListSessionFeedbacks = this.ListSessionFeedbacks.bind(this);
    this.ListRelatedSessions = this.ListRelatedSessions.bind(this);
    this.AddRelatedSession = this.AddRelatedSession.bind(this);
  }
  CreateSession(request: CreateSessionRequest): Promise<CreateSessionResponse> {
    const data = CreateSessionRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateSession", data);
    return promise.then((data) => CreateSessionResponse.decode(_m0.Reader.create(data)));
  }

  GetSession(request: GetSessionRequest): Promise<GetSessionResponse> {
    const data = GetSessionRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetSession", data);
    return promise.then((data) => GetSessionResponse.decode(_m0.Reader.create(data)));
  }

  UpdateSession(request: UpdateSessionRequest): Promise<UpdateSessionResponse> {
    const data = UpdateSessionRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateSession", data);
    return promise.then((data) => UpdateSessionResponse.decode(_m0.Reader.create(data)));
  }

  UpdateSessionStatus(request: UpdateSessionStatusRequest): Promise<UpdateSessionStatusResponse> {
    const data = UpdateSessionStatusRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateSessionStatus", data);
    return promise.then((data) => UpdateSessionStatusResponse.decode(_m0.Reader.create(data)));
  }

  CancelSession(request: CancelSessionRequest): Promise<CancelSessionResponse> {
    const data = CancelSessionRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CancelSession", data);
    return promise.then((data) => CancelSessionResponse.decode(_m0.Reader.create(data)));
  }

  DuplicateSession(request: DuplicateSessionRequest): Promise<DuplicateSessionResponse> {
    const data = DuplicateSessionRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "DuplicateSession", data);
    return promise.then((data) => DuplicateSessionResponse.decode(_m0.Reader.create(data)));
  }

  UpdateSessionSchedule(request: UpdateSessionScheduleRequest): Promise<UpdateSessionScheduleResponse> {
    const data = UpdateSessionScheduleRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateSessionSchedule", data);
    return promise.then((data) => UpdateSessionScheduleResponse.decode(_m0.Reader.create(data)));
  }

  UpdateSessionLocation(request: UpdateSessionLocationRequest): Promise<UpdateSessionLocationResponse> {
    const data = UpdateSessionLocationRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateSessionLocation", data);
    return promise.then((data) => UpdateSessionLocationResponse.decode(_m0.Reader.create(data)));
  }

  ListSessionParticipants(request: ListSessionParticipantsRequest): Promise<ListSessionParticipantsResponse> {
    const data = ListSessionParticipantsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListSessionParticipants", data);
    return promise.then((data) => ListSessionParticipantsResponse.decode(_m0.Reader.create(data)));
  }

  AddSessionParticipant(request: AddSessionParticipantRequest): Promise<AddSessionParticipantResponse> {
    const data = AddSessionParticipantRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "AddSessionParticipant", data);
    return promise.then((data) => AddSessionParticipantResponse.decode(_m0.Reader.create(data)));
  }

  UpdateSessionParticipant(request: UpdateSessionParticipantRequest): Promise<UpdateSessionParticipantResponse> {
    const data = UpdateSessionParticipantRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateSessionParticipant", data);
    return promise.then((data) => UpdateSessionParticipantResponse.decode(_m0.Reader.create(data)));
  }

  AddSongEntry(request: AddSongEntryRequest): Promise<AddSongEntryResponse> {
    const data = AddSongEntryRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "AddSongEntry", data);
    return promise.then((data) => AddSongEntryResponse.decode(_m0.Reader.create(data)));
  }

  DeleteSongEntry(request: DeleteSongEntryRequest): Promise<DeleteSongEntryResponse> {
    const data = DeleteSongEntryRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "DeleteSongEntry", data);
    return promise.then((data) => DeleteSongEntryResponse.decode(_m0.Reader.create(data)));
  }

  AddSessionSongResource(request: AddSessionSongResourceRequest): Promise<AddSessionSongResourceResponse> {
    const data = AddSessionSongResourceRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "AddSessionSongResource", data);
    return promise.then((data) => AddSessionSongResourceResponse.decode(_m0.Reader.create(data)));
  }

  ListSessionSongResources(request: ListSessionSongResourcesRequest): Promise<ListSessionSongResourcesResponse> {
    const data = ListSessionSongResourcesRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListSessionSongResources", data);
    return promise.then((data) => ListSessionSongResourcesResponse.decode(_m0.Reader.create(data)));
  }

  DeleteSessionSongResource(request: DeleteSessionSongResourceRequest): Promise<DeleteSessionSongResourceResponse> {
    const data = DeleteSessionSongResourceRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "DeleteSessionSongResource", data);
    return promise.then((data) => DeleteSessionSongResourceResponse.decode(_m0.Reader.create(data)));
  }

  ListSessionOrganizers(request: ListSessionOrganizersRequest): Promise<ListSessionOrganizersResponse> {
    const data = ListSessionOrganizersRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListSessionOrganizers", data);
    return promise.then((data) => ListSessionOrganizersResponse.decode(_m0.Reader.create(data)));
  }

  AddSessionOrganizer(request: AddSessionOrganizerRequest): Promise<AddSessionOrganizerResponse> {
    const data = AddSessionOrganizerRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "AddSessionOrganizer", data);
    return promise.then((data) => AddSessionOrganizerResponse.decode(_m0.Reader.create(data)));
  }

  DeleteSessionOrganizer(request: DeleteSessionOrganizerRequest): Promise<DeleteSessionOrganizerResponse> {
    const data = DeleteSessionOrganizerRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "DeleteSessionOrganizer", data);
    return promise.then((data) => DeleteSessionOrganizerResponse.decode(_m0.Reader.create(data)));
  }

  CreateSessionThread(request: CreateSessionThreadRequest): Promise<CreateSessionThreadResponse> {
    const data = CreateSessionThreadRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateSessionThread", data);
    return promise.then((data) => CreateSessionThreadResponse.decode(_m0.Reader.create(data)));
  }

  ListSessionThreads(request: ListSessionThreadsRequest): Promise<ListSessionThreadsResponse> {
    const data = ListSessionThreadsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListSessionThreads", data);
    return promise.then((data) => ListSessionThreadsResponse.decode(_m0.Reader.create(data)));
  }

  CreateSongThread(request: CreateSongThreadRequest): Promise<CreateSongThreadResponse> {
    const data = CreateSongThreadRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateSongThread", data);
    return promise.then((data) => CreateSongThreadResponse.decode(_m0.Reader.create(data)));
  }

  GetSessionThread(request: GetSessionThreadRequest): Promise<GetSessionThreadResponse> {
    const data = GetSessionThreadRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetSessionThread", data);
    return promise.then((data) => GetSessionThreadResponse.decode(_m0.Reader.create(data)));
  }

  DeleteSessionThread(request: DeleteSessionThreadRequest): Promise<DeleteSessionThreadResponse> {
    const data = DeleteSessionThreadRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "DeleteSessionThread", data);
    return promise.then((data) => DeleteSessionThreadResponse.decode(_m0.Reader.create(data)));
  }

  CreateSessionNotification(request: CreateSessionNotificationRequest): Promise<CreateSessionNotificationResponse> {
    const data = CreateSessionNotificationRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateSessionNotification", data);
    return promise.then((data) => CreateSessionNotificationResponse.decode(_m0.Reader.create(data)));
  }

  GetSessionTimetable(request: GetSessionTimetableRequest): Promise<GetSessionTimetableResponse> {
    const data = GetSessionTimetableRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetSessionTimetable", data);
    return promise.then((data) => GetSessionTimetableResponse.decode(_m0.Reader.create(data)));
  }

  UpdateSessionTimetable(request: UpdateSessionTimetableRequest): Promise<UpdateSessionTimetableResponse> {
    const data = UpdateSessionTimetableRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateSessionTimetable", data);
    return promise.then((data) => UpdateSessionTimetableResponse.decode(_m0.Reader.create(data)));
  }

  GetOptimizedTimetable(request: GetOptimizedTimetableRequest): Promise<GetOptimizedTimetableResponse> {
    const data = GetOptimizedTimetableRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetOptimizedTimetable", data);
    return promise.then((data) => GetOptimizedTimetableResponse.decode(_m0.Reader.create(data)));
  }

  GetTimetableProgress(request: GetTimetableProgressRequest): Promise<GetTimetableProgressResponse> {
    const data = GetTimetableProgressRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetTimetableProgress", data);
    return promise.then((data) => GetTimetableProgressResponse.decode(_m0.Reader.create(data)));
  }

  UpdateTimetableProgress(request: UpdateTimetableProgressRequest): Promise<UpdateTimetableProgressResponse> {
    const data = UpdateTimetableProgressRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateTimetableProgress", data);
    return promise.then((data) => UpdateTimetableProgressResponse.decode(_m0.Reader.create(data)));
  }

  AddSessionResource(request: AddSessionResourceRequest): Promise<AddSessionResourceResponse> {
    const data = AddSessionResourceRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "AddSessionResource", data);
    return promise.then((data) => AddSessionResourceResponse.decode(_m0.Reader.create(data)));
  }

  ListSessionResources(request: ListSessionResourcesRequest): Promise<ListSessionResourcesResponse> {
    const data = ListSessionResourcesRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListSessionResources", data);
    return promise.then((data) => ListSessionResourcesResponse.decode(_m0.Reader.create(data)));
  }

  DeleteSessionResource(request: DeleteSessionResourceRequest): Promise<DeleteSessionResourceResponse> {
    const data = DeleteSessionResourceRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "DeleteSessionResource", data);
    return promise.then((data) => DeleteSessionResourceResponse.decode(_m0.Reader.create(data)));
  }

  AddSessionFeedback(request: AddSessionFeedbackRequest): Promise<AddSessionFeedbackResponse> {
    const data = AddSessionFeedbackRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "AddSessionFeedback", data);
    return promise.then((data) => AddSessionFeedbackResponse.decode(_m0.Reader.create(data)));
  }

  ListSessionFeedbacks(request: ListSessionFeedbacksRequest): Promise<ListSessionFeedbacksResponse> {
    const data = ListSessionFeedbacksRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListSessionFeedbacks", data);
    return promise.then((data) => ListSessionFeedbacksResponse.decode(_m0.Reader.create(data)));
  }

  ListRelatedSessions(request: ListRelatedSessionsRequest): Promise<ListRelatedSessionsResponse> {
    const data = ListRelatedSessionsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListRelatedSessions", data);
    return promise.then((data) => ListRelatedSessionsResponse.decode(_m0.Reader.create(data)));
  }

  AddRelatedSession(request: AddRelatedSessionRequest): Promise<AddRelatedSessionResponse> {
    const data = AddRelatedSessionRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "AddRelatedSession", data);
    return promise.then((data) => AddRelatedSessionResponse.decode(_m0.Reader.create(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
