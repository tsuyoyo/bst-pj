// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v5.29.3
// source: bst/v1/thread_service.proto

/* eslint-disable */
import _m0 from "protobufjs/minimal";
import { Comment, Thread } from "./communication";

export const protobufPackage = "bst.v1";

export interface GetThreadRequest {
  id: number;
}

export interface GetThreadsInSessionRequest {
  sessionId: number;
}

export interface GetThreadsInSessionResponse {
  threads: Thread[];
}

export interface GetThreadCommentsRequest {
  threadId: number;
  page: number;
  limit: number;
}

export interface GetThreadCommentsResponse {
  comments: Comment[];
  nextPage: number;
}

export interface PostThreadRequest {
  title: string;
  description: string;
  userId: number;
}

export interface PostThreadInSessionRequest {
  title: string;
  description: string;
  userId: number;
  sessionId: number;
}

export interface UpdateThreadTitleRequest {
  id: number;
  title: string;
}

export interface UpdateThreadRequest {
  id: number;
  title: string;
  description: string;
}

export interface UpdateThreadDescriptionRequest {
  id: number;
  description: string;
}

export interface DeleteThreadRequest {
  id: number;
}

export interface DeleteThreadResponse {
  success: boolean;
}

function createBaseGetThreadRequest(): GetThreadRequest {
  return { id: 0 };
}

export const GetThreadRequest = {
  encode(message: GetThreadRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetThreadRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetThreadRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetThreadRequest {
    return { id: isSet(object.id) ? globalThis.Number(object.id) : 0 };
  },

  toJSON(message: GetThreadRequest): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetThreadRequest>, I>>(base?: I): GetThreadRequest {
    return GetThreadRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetThreadRequest>, I>>(object: I): GetThreadRequest {
    const message = createBaseGetThreadRequest();
    message.id = object.id ?? 0;
    return message;
  },
};

function createBaseGetThreadsInSessionRequest(): GetThreadsInSessionRequest {
  return { sessionId: 0 };
}

export const GetThreadsInSessionRequest = {
  encode(message: GetThreadsInSessionRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== 0) {
      writer.uint32(8).int32(message.sessionId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetThreadsInSessionRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetThreadsInSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sessionId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetThreadsInSessionRequest {
    return { sessionId: isSet(object.sessionId) ? globalThis.Number(object.sessionId) : 0 };
  },

  toJSON(message: GetThreadsInSessionRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== 0) {
      obj.sessionId = Math.round(message.sessionId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetThreadsInSessionRequest>, I>>(base?: I): GetThreadsInSessionRequest {
    return GetThreadsInSessionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetThreadsInSessionRequest>, I>>(object: I): GetThreadsInSessionRequest {
    const message = createBaseGetThreadsInSessionRequest();
    message.sessionId = object.sessionId ?? 0;
    return message;
  },
};

function createBaseGetThreadsInSessionResponse(): GetThreadsInSessionResponse {
  return { threads: [] };
}

export const GetThreadsInSessionResponse = {
  encode(message: GetThreadsInSessionResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.threads) {
      Thread.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetThreadsInSessionResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetThreadsInSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.threads.push(Thread.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetThreadsInSessionResponse {
    return {
      threads: globalThis.Array.isArray(object?.threads) ? object.threads.map((e: any) => Thread.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetThreadsInSessionResponse): unknown {
    const obj: any = {};
    if (message.threads?.length) {
      obj.threads = message.threads.map((e) => Thread.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetThreadsInSessionResponse>, I>>(base?: I): GetThreadsInSessionResponse {
    return GetThreadsInSessionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetThreadsInSessionResponse>, I>>(object: I): GetThreadsInSessionResponse {
    const message = createBaseGetThreadsInSessionResponse();
    message.threads = object.threads?.map((e) => Thread.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetThreadCommentsRequest(): GetThreadCommentsRequest {
  return { threadId: 0, page: 0, limit: 0 };
}

export const GetThreadCommentsRequest = {
  encode(message: GetThreadCommentsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.threadId !== 0) {
      writer.uint32(8).int32(message.threadId);
    }
    if (message.page !== 0) {
      writer.uint32(16).int32(message.page);
    }
    if (message.limit !== 0) {
      writer.uint32(24).int32(message.limit);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetThreadCommentsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetThreadCommentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.threadId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.page = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.limit = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetThreadCommentsRequest {
    return {
      threadId: isSet(object.threadId) ? globalThis.Number(object.threadId) : 0,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
    };
  },

  toJSON(message: GetThreadCommentsRequest): unknown {
    const obj: any = {};
    if (message.threadId !== 0) {
      obj.threadId = Math.round(message.threadId);
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetThreadCommentsRequest>, I>>(base?: I): GetThreadCommentsRequest {
    return GetThreadCommentsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetThreadCommentsRequest>, I>>(object: I): GetThreadCommentsRequest {
    const message = createBaseGetThreadCommentsRequest();
    message.threadId = object.threadId ?? 0;
    message.page = object.page ?? 0;
    message.limit = object.limit ?? 0;
    return message;
  },
};

function createBaseGetThreadCommentsResponse(): GetThreadCommentsResponse {
  return { comments: [], nextPage: 0 };
}

export const GetThreadCommentsResponse = {
  encode(message: GetThreadCommentsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.comments) {
      Comment.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.nextPage !== 0) {
      writer.uint32(16).int32(message.nextPage);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetThreadCommentsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetThreadCommentsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.comments.push(Comment.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.nextPage = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetThreadCommentsResponse {
    return {
      comments: globalThis.Array.isArray(object?.comments) ? object.comments.map((e: any) => Comment.fromJSON(e)) : [],
      nextPage: isSet(object.nextPage) ? globalThis.Number(object.nextPage) : 0,
    };
  },

  toJSON(message: GetThreadCommentsResponse): unknown {
    const obj: any = {};
    if (message.comments?.length) {
      obj.comments = message.comments.map((e) => Comment.toJSON(e));
    }
    if (message.nextPage !== 0) {
      obj.nextPage = Math.round(message.nextPage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetThreadCommentsResponse>, I>>(base?: I): GetThreadCommentsResponse {
    return GetThreadCommentsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetThreadCommentsResponse>, I>>(object: I): GetThreadCommentsResponse {
    const message = createBaseGetThreadCommentsResponse();
    message.comments = object.comments?.map((e) => Comment.fromPartial(e)) || [];
    message.nextPage = object.nextPage ?? 0;
    return message;
  },
};

function createBasePostThreadRequest(): PostThreadRequest {
  return { title: "", description: "", userId: 0 };
}

export const PostThreadRequest = {
  encode(message: PostThreadRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.userId !== 0) {
      writer.uint32(24).int32(message.userId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PostThreadRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostThreadRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.title = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.userId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostThreadRequest {
    return {
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      userId: isSet(object.userId) ? globalThis.Number(object.userId) : 0,
    };
  },

  toJSON(message: PostThreadRequest): unknown {
    const obj: any = {};
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.userId !== 0) {
      obj.userId = Math.round(message.userId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostThreadRequest>, I>>(base?: I): PostThreadRequest {
    return PostThreadRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostThreadRequest>, I>>(object: I): PostThreadRequest {
    const message = createBasePostThreadRequest();
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.userId = object.userId ?? 0;
    return message;
  },
};

function createBasePostThreadInSessionRequest(): PostThreadInSessionRequest {
  return { title: "", description: "", userId: 0, sessionId: 0 };
}

export const PostThreadInSessionRequest = {
  encode(message: PostThreadInSessionRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.userId !== 0) {
      writer.uint32(24).int32(message.userId);
    }
    if (message.sessionId !== 0) {
      writer.uint32(32).int32(message.sessionId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PostThreadInSessionRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostThreadInSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.title = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.userId = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.sessionId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostThreadInSessionRequest {
    return {
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      userId: isSet(object.userId) ? globalThis.Number(object.userId) : 0,
      sessionId: isSet(object.sessionId) ? globalThis.Number(object.sessionId) : 0,
    };
  },

  toJSON(message: PostThreadInSessionRequest): unknown {
    const obj: any = {};
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.userId !== 0) {
      obj.userId = Math.round(message.userId);
    }
    if (message.sessionId !== 0) {
      obj.sessionId = Math.round(message.sessionId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostThreadInSessionRequest>, I>>(base?: I): PostThreadInSessionRequest {
    return PostThreadInSessionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostThreadInSessionRequest>, I>>(object: I): PostThreadInSessionRequest {
    const message = createBasePostThreadInSessionRequest();
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.userId = object.userId ?? 0;
    message.sessionId = object.sessionId ?? 0;
    return message;
  },
};

function createBaseUpdateThreadTitleRequest(): UpdateThreadTitleRequest {
  return { id: 0, title: "" };
}

export const UpdateThreadTitleRequest = {
  encode(message: UpdateThreadTitleRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateThreadTitleRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateThreadTitleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateThreadTitleRequest {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      title: isSet(object.title) ? globalThis.String(object.title) : "",
    };
  },

  toJSON(message: UpdateThreadTitleRequest): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateThreadTitleRequest>, I>>(base?: I): UpdateThreadTitleRequest {
    return UpdateThreadTitleRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateThreadTitleRequest>, I>>(object: I): UpdateThreadTitleRequest {
    const message = createBaseUpdateThreadTitleRequest();
    message.id = object.id ?? 0;
    message.title = object.title ?? "";
    return message;
  },
};

function createBaseUpdateThreadRequest(): UpdateThreadRequest {
  return { id: 0, title: "", description: "" };
}

export const UpdateThreadRequest = {
  encode(message: UpdateThreadRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateThreadRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateThreadRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateThreadRequest {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: UpdateThreadRequest): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateThreadRequest>, I>>(base?: I): UpdateThreadRequest {
    return UpdateThreadRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateThreadRequest>, I>>(object: I): UpdateThreadRequest {
    const message = createBaseUpdateThreadRequest();
    message.id = object.id ?? 0;
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseUpdateThreadDescriptionRequest(): UpdateThreadDescriptionRequest {
  return { id: 0, description: "" };
}

export const UpdateThreadDescriptionRequest = {
  encode(message: UpdateThreadDescriptionRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateThreadDescriptionRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateThreadDescriptionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateThreadDescriptionRequest {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: UpdateThreadDescriptionRequest): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateThreadDescriptionRequest>, I>>(base?: I): UpdateThreadDescriptionRequest {
    return UpdateThreadDescriptionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateThreadDescriptionRequest>, I>>(
    object: I,
  ): UpdateThreadDescriptionRequest {
    const message = createBaseUpdateThreadDescriptionRequest();
    message.id = object.id ?? 0;
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseDeleteThreadRequest(): DeleteThreadRequest {
  return { id: 0 };
}

export const DeleteThreadRequest = {
  encode(message: DeleteThreadRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteThreadRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteThreadRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteThreadRequest {
    return { id: isSet(object.id) ? globalThis.Number(object.id) : 0 };
  },

  toJSON(message: DeleteThreadRequest): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteThreadRequest>, I>>(base?: I): DeleteThreadRequest {
    return DeleteThreadRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteThreadRequest>, I>>(object: I): DeleteThreadRequest {
    const message = createBaseDeleteThreadRequest();
    message.id = object.id ?? 0;
    return message;
  },
};

function createBaseDeleteThreadResponse(): DeleteThreadResponse {
  return { success: false };
}

export const DeleteThreadResponse = {
  encode(message: DeleteThreadResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteThreadResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteThreadResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteThreadResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: DeleteThreadResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteThreadResponse>, I>>(base?: I): DeleteThreadResponse {
    return DeleteThreadResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteThreadResponse>, I>>(object: I): DeleteThreadResponse {
    const message = createBaseDeleteThreadResponse();
    message.success = object.success ?? false;
    return message;
  },
};

export interface ThreadService {
  GetThread(request: GetThreadRequest): Promise<Thread>;
  GetThreadsInSession(request: GetThreadsInSessionRequest): Promise<GetThreadsInSessionResponse>;
  GetThreadComments(request: GetThreadCommentsRequest): Promise<GetThreadCommentsResponse>;
  CreateThread(request: PostThreadRequest): Promise<Thread>;
  CreateThreadInSession(request: PostThreadInSessionRequest): Promise<Thread>;
  UpdateThreadTitle(request: UpdateThreadTitleRequest): Promise<Thread>;
  UpdateThreadDescription(request: UpdateThreadDescriptionRequest): Promise<Thread>;
  DeleteThread(request: DeleteThreadRequest): Promise<DeleteThreadResponse>;
}

export const ThreadServiceServiceName = "bst.v1.ThreadService";
export class ThreadServiceClientImpl implements ThreadService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || ThreadServiceServiceName;
    this.rpc = rpc;
    this.GetThread = this.GetThread.bind(this);
    this.GetThreadsInSession = this.GetThreadsInSession.bind(this);
    this.GetThreadComments = this.GetThreadComments.bind(this);
    this.CreateThread = this.CreateThread.bind(this);
    this.CreateThreadInSession = this.CreateThreadInSession.bind(this);
    this.UpdateThreadTitle = this.UpdateThreadTitle.bind(this);
    this.UpdateThreadDescription = this.UpdateThreadDescription.bind(this);
    this.DeleteThread = this.DeleteThread.bind(this);
  }
  GetThread(request: GetThreadRequest): Promise<Thread> {
    const data = GetThreadRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetThread", data);
    return promise.then((data) => Thread.decode(_m0.Reader.create(data)));
  }

  GetThreadsInSession(request: GetThreadsInSessionRequest): Promise<GetThreadsInSessionResponse> {
    const data = GetThreadsInSessionRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetThreadsInSession", data);
    return promise.then((data) => GetThreadsInSessionResponse.decode(_m0.Reader.create(data)));
  }

  GetThreadComments(request: GetThreadCommentsRequest): Promise<GetThreadCommentsResponse> {
    const data = GetThreadCommentsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetThreadComments", data);
    return promise.then((data) => GetThreadCommentsResponse.decode(_m0.Reader.create(data)));
  }

  CreateThread(request: PostThreadRequest): Promise<Thread> {
    const data = PostThreadRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateThread", data);
    return promise.then((data) => Thread.decode(_m0.Reader.create(data)));
  }

  CreateThreadInSession(request: PostThreadInSessionRequest): Promise<Thread> {
    const data = PostThreadInSessionRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateThreadInSession", data);
    return promise.then((data) => Thread.decode(_m0.Reader.create(data)));
  }

  UpdateThreadTitle(request: UpdateThreadTitleRequest): Promise<Thread> {
    const data = UpdateThreadTitleRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateThreadTitle", data);
    return promise.then((data) => Thread.decode(_m0.Reader.create(data)));
  }

  UpdateThreadDescription(request: UpdateThreadDescriptionRequest): Promise<Thread> {
    const data = UpdateThreadDescriptionRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateThreadDescription", data);
    return promise.then((data) => Thread.decode(_m0.Reader.create(data)));
  }

  DeleteThread(request: DeleteThreadRequest): Promise<DeleteThreadResponse> {
    const data = DeleteThreadRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "DeleteThread", data);
    return promise.then((data) => DeleteThreadResponse.decode(_m0.Reader.create(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
