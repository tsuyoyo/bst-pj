// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v5.29.3
// source: song_service.proto

/* eslint-disable */
import _m0 from "protobufjs/minimal";
import { Artist, Genre, Resource, Song } from "./content";

export const protobufPackage = "bst.v1";

export interface CreateSongRequest {
  title: string;
  artist: Artist | undefined;
  genre: Genre | undefined;
  description: string;
}

export interface CreateSongResponse {
  song: Song | undefined;
}

export interface ListSongsRequest {
  pageSize: number;
  pageToken: number;
  query: string;
  genre: Genre | undefined;
  artistId: number;
}

export interface ListSongsResponse {
  songs: Song[];
  nextPageToken: string;
  totalSize: number;
}

export interface GetSongRequest {
  songId: number;
}

export interface GetSongResponse {
  song: Song | undefined;
}

export interface UpdateSongRequest {
  songId: number;
  title: string;
  artist: Artist | undefined;
  genre: Genre | undefined;
  description: string;
}

export interface UpdateSongResponse {
  song: Song | undefined;
}

export interface DeleteSongRequest {
  songId: number;
}

export interface DeleteSongResponse {
  success: boolean;
}

export interface AddSongResourceRequest {
  songId: number;
  resource: Resource | undefined;
}

export interface AddSongResourceResponse {
  resource: Resource | undefined;
}

export interface ListSongResourcesRequest {
  songId: number;
  pageSize: number;
  pageToken: number;
}

export interface ListSongResourcesResponse {
  resources: Resource[];
  nextPageToken: string;
  totalSize: number;
}

export interface DeleteSongResourceRequest {
  songId: number;
  resourceId: number;
}

export interface DeleteSongResourceResponse {
  success: boolean;
}

function createBaseCreateSongRequest(): CreateSongRequest {
  return { title: "", artist: undefined, genre: undefined, description: "" };
}

export const CreateSongRequest = {
  encode(message: CreateSongRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.artist !== undefined) {
      Artist.encode(message.artist, writer.uint32(18).fork()).ldelim();
    }
    if (message.genre !== undefined) {
      Genre.encode(message.genre, writer.uint32(26).fork()).ldelim();
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateSongRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSongRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.title = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.artist = Artist.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.genre = Genre.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSongRequest {
    return {
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      artist: isSet(object.artist) ? Artist.fromJSON(object.artist) : undefined,
      genre: isSet(object.genre) ? Genre.fromJSON(object.genre) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: CreateSongRequest): unknown {
    const obj: any = {};
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.artist !== undefined) {
      obj.artist = Artist.toJSON(message.artist);
    }
    if (message.genre !== undefined) {
      obj.genre = Genre.toJSON(message.genre);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateSongRequest>, I>>(base?: I): CreateSongRequest {
    return CreateSongRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateSongRequest>, I>>(object: I): CreateSongRequest {
    const message = createBaseCreateSongRequest();
    message.title = object.title ?? "";
    message.artist = (object.artist !== undefined && object.artist !== null)
      ? Artist.fromPartial(object.artist)
      : undefined;
    message.genre = (object.genre !== undefined && object.genre !== null) ? Genre.fromPartial(object.genre) : undefined;
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseCreateSongResponse(): CreateSongResponse {
  return { song: undefined };
}

export const CreateSongResponse = {
  encode(message: CreateSongResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.song !== undefined) {
      Song.encode(message.song, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateSongResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSongResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.song = Song.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSongResponse {
    return { song: isSet(object.song) ? Song.fromJSON(object.song) : undefined };
  },

  toJSON(message: CreateSongResponse): unknown {
    const obj: any = {};
    if (message.song !== undefined) {
      obj.song = Song.toJSON(message.song);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateSongResponse>, I>>(base?: I): CreateSongResponse {
    return CreateSongResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateSongResponse>, I>>(object: I): CreateSongResponse {
    const message = createBaseCreateSongResponse();
    message.song = (object.song !== undefined && object.song !== null) ? Song.fromPartial(object.song) : undefined;
    return message;
  },
};

function createBaseListSongsRequest(): ListSongsRequest {
  return { pageSize: 0, pageToken: 0, query: "", genre: undefined, artistId: 0 };
}

export const ListSongsRequest = {
  encode(message: ListSongsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pageSize !== 0) {
      writer.uint32(8).int32(message.pageSize);
    }
    if (message.pageToken !== 0) {
      writer.uint32(16).int32(message.pageToken);
    }
    if (message.query !== "") {
      writer.uint32(26).string(message.query);
    }
    if (message.genre !== undefined) {
      Genre.encode(message.genre, writer.uint32(34).fork()).ldelim();
    }
    if (message.artistId !== 0) {
      writer.uint32(40).int32(message.artistId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListSongsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSongsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageToken = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.query = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.genre = Genre.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.artistId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSongsRequest {
    return {
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.Number(object.pageToken) : 0,
      query: isSet(object.query) ? globalThis.String(object.query) : "",
      genre: isSet(object.genre) ? Genre.fromJSON(object.genre) : undefined,
      artistId: isSet(object.artistId) ? globalThis.Number(object.artistId) : 0,
    };
  },

  toJSON(message: ListSongsRequest): unknown {
    const obj: any = {};
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== 0) {
      obj.pageToken = Math.round(message.pageToken);
    }
    if (message.query !== "") {
      obj.query = message.query;
    }
    if (message.genre !== undefined) {
      obj.genre = Genre.toJSON(message.genre);
    }
    if (message.artistId !== 0) {
      obj.artistId = Math.round(message.artistId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListSongsRequest>, I>>(base?: I): ListSongsRequest {
    return ListSongsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListSongsRequest>, I>>(object: I): ListSongsRequest {
    const message = createBaseListSongsRequest();
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? 0;
    message.query = object.query ?? "";
    message.genre = (object.genre !== undefined && object.genre !== null) ? Genre.fromPartial(object.genre) : undefined;
    message.artistId = object.artistId ?? 0;
    return message;
  },
};

function createBaseListSongsResponse(): ListSongsResponse {
  return { songs: [], nextPageToken: "", totalSize: 0 };
}

export const ListSongsResponse = {
  encode(message: ListSongsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.songs) {
      Song.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    if (message.totalSize !== 0) {
      writer.uint32(24).int32(message.totalSize);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListSongsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSongsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.songs.push(Song.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.totalSize = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSongsResponse {
    return {
      songs: globalThis.Array.isArray(object?.songs) ? object.songs.map((e: any) => Song.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      totalSize: isSet(object.totalSize) ? globalThis.Number(object.totalSize) : 0,
    };
  },

  toJSON(message: ListSongsResponse): unknown {
    const obj: any = {};
    if (message.songs?.length) {
      obj.songs = message.songs.map((e) => Song.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.totalSize !== 0) {
      obj.totalSize = Math.round(message.totalSize);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListSongsResponse>, I>>(base?: I): ListSongsResponse {
    return ListSongsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListSongsResponse>, I>>(object: I): ListSongsResponse {
    const message = createBaseListSongsResponse();
    message.songs = object.songs?.map((e) => Song.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.totalSize = object.totalSize ?? 0;
    return message;
  },
};

function createBaseGetSongRequest(): GetSongRequest {
  return { songId: 0 };
}

export const GetSongRequest = {
  encode(message: GetSongRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.songId !== 0) {
      writer.uint32(8).int32(message.songId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetSongRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSongRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.songId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSongRequest {
    return { songId: isSet(object.songId) ? globalThis.Number(object.songId) : 0 };
  },

  toJSON(message: GetSongRequest): unknown {
    const obj: any = {};
    if (message.songId !== 0) {
      obj.songId = Math.round(message.songId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSongRequest>, I>>(base?: I): GetSongRequest {
    return GetSongRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSongRequest>, I>>(object: I): GetSongRequest {
    const message = createBaseGetSongRequest();
    message.songId = object.songId ?? 0;
    return message;
  },
};

function createBaseGetSongResponse(): GetSongResponse {
  return { song: undefined };
}

export const GetSongResponse = {
  encode(message: GetSongResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.song !== undefined) {
      Song.encode(message.song, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetSongResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSongResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.song = Song.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSongResponse {
    return { song: isSet(object.song) ? Song.fromJSON(object.song) : undefined };
  },

  toJSON(message: GetSongResponse): unknown {
    const obj: any = {};
    if (message.song !== undefined) {
      obj.song = Song.toJSON(message.song);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSongResponse>, I>>(base?: I): GetSongResponse {
    return GetSongResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSongResponse>, I>>(object: I): GetSongResponse {
    const message = createBaseGetSongResponse();
    message.song = (object.song !== undefined && object.song !== null) ? Song.fromPartial(object.song) : undefined;
    return message;
  },
};

function createBaseUpdateSongRequest(): UpdateSongRequest {
  return { songId: 0, title: "", artist: undefined, genre: undefined, description: "" };
}

export const UpdateSongRequest = {
  encode(message: UpdateSongRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.songId !== 0) {
      writer.uint32(8).int32(message.songId);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.artist !== undefined) {
      Artist.encode(message.artist, writer.uint32(26).fork()).ldelim();
    }
    if (message.genre !== undefined) {
      Genre.encode(message.genre, writer.uint32(34).fork()).ldelim();
    }
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateSongRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSongRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.songId = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.artist = Artist.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.genre = Genre.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateSongRequest {
    return {
      songId: isSet(object.songId) ? globalThis.Number(object.songId) : 0,
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      artist: isSet(object.artist) ? Artist.fromJSON(object.artist) : undefined,
      genre: isSet(object.genre) ? Genre.fromJSON(object.genre) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: UpdateSongRequest): unknown {
    const obj: any = {};
    if (message.songId !== 0) {
      obj.songId = Math.round(message.songId);
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.artist !== undefined) {
      obj.artist = Artist.toJSON(message.artist);
    }
    if (message.genre !== undefined) {
      obj.genre = Genre.toJSON(message.genre);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateSongRequest>, I>>(base?: I): UpdateSongRequest {
    return UpdateSongRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateSongRequest>, I>>(object: I): UpdateSongRequest {
    const message = createBaseUpdateSongRequest();
    message.songId = object.songId ?? 0;
    message.title = object.title ?? "";
    message.artist = (object.artist !== undefined && object.artist !== null)
      ? Artist.fromPartial(object.artist)
      : undefined;
    message.genre = (object.genre !== undefined && object.genre !== null) ? Genre.fromPartial(object.genre) : undefined;
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseUpdateSongResponse(): UpdateSongResponse {
  return { song: undefined };
}

export const UpdateSongResponse = {
  encode(message: UpdateSongResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.song !== undefined) {
      Song.encode(message.song, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateSongResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSongResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.song = Song.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateSongResponse {
    return { song: isSet(object.song) ? Song.fromJSON(object.song) : undefined };
  },

  toJSON(message: UpdateSongResponse): unknown {
    const obj: any = {};
    if (message.song !== undefined) {
      obj.song = Song.toJSON(message.song);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateSongResponse>, I>>(base?: I): UpdateSongResponse {
    return UpdateSongResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateSongResponse>, I>>(object: I): UpdateSongResponse {
    const message = createBaseUpdateSongResponse();
    message.song = (object.song !== undefined && object.song !== null) ? Song.fromPartial(object.song) : undefined;
    return message;
  },
};

function createBaseDeleteSongRequest(): DeleteSongRequest {
  return { songId: 0 };
}

export const DeleteSongRequest = {
  encode(message: DeleteSongRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.songId !== 0) {
      writer.uint32(8).int32(message.songId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteSongRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteSongRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.songId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteSongRequest {
    return { songId: isSet(object.songId) ? globalThis.Number(object.songId) : 0 };
  },

  toJSON(message: DeleteSongRequest): unknown {
    const obj: any = {};
    if (message.songId !== 0) {
      obj.songId = Math.round(message.songId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteSongRequest>, I>>(base?: I): DeleteSongRequest {
    return DeleteSongRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteSongRequest>, I>>(object: I): DeleteSongRequest {
    const message = createBaseDeleteSongRequest();
    message.songId = object.songId ?? 0;
    return message;
  },
};

function createBaseDeleteSongResponse(): DeleteSongResponse {
  return { success: false };
}

export const DeleteSongResponse = {
  encode(message: DeleteSongResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteSongResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteSongResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteSongResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: DeleteSongResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteSongResponse>, I>>(base?: I): DeleteSongResponse {
    return DeleteSongResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteSongResponse>, I>>(object: I): DeleteSongResponse {
    const message = createBaseDeleteSongResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseAddSongResourceRequest(): AddSongResourceRequest {
  return { songId: 0, resource: undefined };
}

export const AddSongResourceRequest = {
  encode(message: AddSongResourceRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.songId !== 0) {
      writer.uint32(8).int32(message.songId);
    }
    if (message.resource !== undefined) {
      Resource.encode(message.resource, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AddSongResourceRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddSongResourceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.songId = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.resource = Resource.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddSongResourceRequest {
    return {
      songId: isSet(object.songId) ? globalThis.Number(object.songId) : 0,
      resource: isSet(object.resource) ? Resource.fromJSON(object.resource) : undefined,
    };
  },

  toJSON(message: AddSongResourceRequest): unknown {
    const obj: any = {};
    if (message.songId !== 0) {
      obj.songId = Math.round(message.songId);
    }
    if (message.resource !== undefined) {
      obj.resource = Resource.toJSON(message.resource);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddSongResourceRequest>, I>>(base?: I): AddSongResourceRequest {
    return AddSongResourceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddSongResourceRequest>, I>>(object: I): AddSongResourceRequest {
    const message = createBaseAddSongResourceRequest();
    message.songId = object.songId ?? 0;
    message.resource = (object.resource !== undefined && object.resource !== null)
      ? Resource.fromPartial(object.resource)
      : undefined;
    return message;
  },
};

function createBaseAddSongResourceResponse(): AddSongResourceResponse {
  return { resource: undefined };
}

export const AddSongResourceResponse = {
  encode(message: AddSongResourceResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.resource !== undefined) {
      Resource.encode(message.resource, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AddSongResourceResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddSongResourceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.resource = Resource.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddSongResourceResponse {
    return { resource: isSet(object.resource) ? Resource.fromJSON(object.resource) : undefined };
  },

  toJSON(message: AddSongResourceResponse): unknown {
    const obj: any = {};
    if (message.resource !== undefined) {
      obj.resource = Resource.toJSON(message.resource);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddSongResourceResponse>, I>>(base?: I): AddSongResourceResponse {
    return AddSongResourceResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddSongResourceResponse>, I>>(object: I): AddSongResourceResponse {
    const message = createBaseAddSongResourceResponse();
    message.resource = (object.resource !== undefined && object.resource !== null)
      ? Resource.fromPartial(object.resource)
      : undefined;
    return message;
  },
};

function createBaseListSongResourcesRequest(): ListSongResourcesRequest {
  return { songId: 0, pageSize: 0, pageToken: 0 };
}

export const ListSongResourcesRequest = {
  encode(message: ListSongResourcesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.songId !== 0) {
      writer.uint32(8).int32(message.songId);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== 0) {
      writer.uint32(24).int32(message.pageToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListSongResourcesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSongResourcesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.songId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.pageToken = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSongResourcesRequest {
    return {
      songId: isSet(object.songId) ? globalThis.Number(object.songId) : 0,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.Number(object.pageToken) : 0,
    };
  },

  toJSON(message: ListSongResourcesRequest): unknown {
    const obj: any = {};
    if (message.songId !== 0) {
      obj.songId = Math.round(message.songId);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== 0) {
      obj.pageToken = Math.round(message.pageToken);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListSongResourcesRequest>, I>>(base?: I): ListSongResourcesRequest {
    return ListSongResourcesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListSongResourcesRequest>, I>>(object: I): ListSongResourcesRequest {
    const message = createBaseListSongResourcesRequest();
    message.songId = object.songId ?? 0;
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? 0;
    return message;
  },
};

function createBaseListSongResourcesResponse(): ListSongResourcesResponse {
  return { resources: [], nextPageToken: "", totalSize: 0 };
}

export const ListSongResourcesResponse = {
  encode(message: ListSongResourcesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.resources) {
      Resource.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    if (message.totalSize !== 0) {
      writer.uint32(24).int32(message.totalSize);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListSongResourcesResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSongResourcesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.resources.push(Resource.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.totalSize = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSongResourcesResponse {
    return {
      resources: globalThis.Array.isArray(object?.resources)
        ? object.resources.map((e: any) => Resource.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      totalSize: isSet(object.totalSize) ? globalThis.Number(object.totalSize) : 0,
    };
  },

  toJSON(message: ListSongResourcesResponse): unknown {
    const obj: any = {};
    if (message.resources?.length) {
      obj.resources = message.resources.map((e) => Resource.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.totalSize !== 0) {
      obj.totalSize = Math.round(message.totalSize);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListSongResourcesResponse>, I>>(base?: I): ListSongResourcesResponse {
    return ListSongResourcesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListSongResourcesResponse>, I>>(object: I): ListSongResourcesResponse {
    const message = createBaseListSongResourcesResponse();
    message.resources = object.resources?.map((e) => Resource.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.totalSize = object.totalSize ?? 0;
    return message;
  },
};

function createBaseDeleteSongResourceRequest(): DeleteSongResourceRequest {
  return { songId: 0, resourceId: 0 };
}

export const DeleteSongResourceRequest = {
  encode(message: DeleteSongResourceRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.songId !== 0) {
      writer.uint32(8).int32(message.songId);
    }
    if (message.resourceId !== 0) {
      writer.uint32(16).int32(message.resourceId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteSongResourceRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteSongResourceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.songId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.resourceId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteSongResourceRequest {
    return {
      songId: isSet(object.songId) ? globalThis.Number(object.songId) : 0,
      resourceId: isSet(object.resourceId) ? globalThis.Number(object.resourceId) : 0,
    };
  },

  toJSON(message: DeleteSongResourceRequest): unknown {
    const obj: any = {};
    if (message.songId !== 0) {
      obj.songId = Math.round(message.songId);
    }
    if (message.resourceId !== 0) {
      obj.resourceId = Math.round(message.resourceId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteSongResourceRequest>, I>>(base?: I): DeleteSongResourceRequest {
    return DeleteSongResourceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteSongResourceRequest>, I>>(object: I): DeleteSongResourceRequest {
    const message = createBaseDeleteSongResourceRequest();
    message.songId = object.songId ?? 0;
    message.resourceId = object.resourceId ?? 0;
    return message;
  },
};

function createBaseDeleteSongResourceResponse(): DeleteSongResourceResponse {
  return { success: false };
}

export const DeleteSongResourceResponse = {
  encode(message: DeleteSongResourceResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteSongResourceResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteSongResourceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteSongResourceResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: DeleteSongResourceResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteSongResourceResponse>, I>>(base?: I): DeleteSongResourceResponse {
    return DeleteSongResourceResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteSongResourceResponse>, I>>(object: I): DeleteSongResourceResponse {
    const message = createBaseDeleteSongResourceResponse();
    message.success = object.success ?? false;
    return message;
  },
};

export interface SongService {
  /** POST /songs */
  CreateSong(request: CreateSongRequest): Promise<CreateSongResponse>;
  /** GET /songs */
  ListSongs(request: ListSongsRequest): Promise<ListSongsResponse>;
  /** GET /songs/{id} */
  GetSong(request: GetSongRequest): Promise<GetSongResponse>;
  /** PUT /songs/{id} */
  UpdateSong(request: UpdateSongRequest): Promise<UpdateSongResponse>;
  /** DELETE /songs/{id} */
  DeleteSong(request: DeleteSongRequest): Promise<DeleteSongResponse>;
  /** POST /songs/{id}/resources */
  AddSongResource(request: AddSongResourceRequest): Promise<AddSongResourceResponse>;
  /** GET /songs/{id}/resources */
  ListSongResources(request: ListSongResourcesRequest): Promise<ListSongResourcesResponse>;
  /** DELETE /songs/{id}/resources/{resourceId} */
  DeleteSongResource(request: DeleteSongResourceRequest): Promise<DeleteSongResourceResponse>;
}

export const SongServiceServiceName = "bst.v1.SongService";
export class SongServiceClientImpl implements SongService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || SongServiceServiceName;
    this.rpc = rpc;
    this.CreateSong = this.CreateSong.bind(this);
    this.ListSongs = this.ListSongs.bind(this);
    this.GetSong = this.GetSong.bind(this);
    this.UpdateSong = this.UpdateSong.bind(this);
    this.DeleteSong = this.DeleteSong.bind(this);
    this.AddSongResource = this.AddSongResource.bind(this);
    this.ListSongResources = this.ListSongResources.bind(this);
    this.DeleteSongResource = this.DeleteSongResource.bind(this);
  }
  CreateSong(request: CreateSongRequest): Promise<CreateSongResponse> {
    const data = CreateSongRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateSong", data);
    return promise.then((data) => CreateSongResponse.decode(_m0.Reader.create(data)));
  }

  ListSongs(request: ListSongsRequest): Promise<ListSongsResponse> {
    const data = ListSongsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListSongs", data);
    return promise.then((data) => ListSongsResponse.decode(_m0.Reader.create(data)));
  }

  GetSong(request: GetSongRequest): Promise<GetSongResponse> {
    const data = GetSongRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetSong", data);
    return promise.then((data) => GetSongResponse.decode(_m0.Reader.create(data)));
  }

  UpdateSong(request: UpdateSongRequest): Promise<UpdateSongResponse> {
    const data = UpdateSongRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateSong", data);
    return promise.then((data) => UpdateSongResponse.decode(_m0.Reader.create(data)));
  }

  DeleteSong(request: DeleteSongRequest): Promise<DeleteSongResponse> {
    const data = DeleteSongRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "DeleteSong", data);
    return promise.then((data) => DeleteSongResponse.decode(_m0.Reader.create(data)));
  }

  AddSongResource(request: AddSongResourceRequest): Promise<AddSongResourceResponse> {
    const data = AddSongResourceRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "AddSongResource", data);
    return promise.then((data) => AddSongResourceResponse.decode(_m0.Reader.create(data)));
  }

  ListSongResources(request: ListSongResourcesRequest): Promise<ListSongResourcesResponse> {
    const data = ListSongResourcesRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListSongResources", data);
    return promise.then((data) => ListSongResourcesResponse.decode(_m0.Reader.create(data)));
  }

  DeleteSongResource(request: DeleteSongResourceRequest): Promise<DeleteSongResourceResponse> {
    const data = DeleteSongResourceRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "DeleteSongResource", data);
    return promise.then((data) => DeleteSongResourceResponse.decode(_m0.Reader.create(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
